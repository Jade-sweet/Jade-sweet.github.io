{"pages":[],"posts":[{"title":"HTML基础","text":"1.web标准 - W3C制定的网页开发规范，这个规范分为三类，分别是： 结构标准 - HTML，决定网页中的内容（网页中有什么东西）表现标准 - CSS，决定网页中内容的布局和样式行为标准 - JavaScript，决定网页中动态变化的部分 2.HTML 超文本标记语言（和Markdown一样）HTML中大小写不敏感（语法或关键字中），例如head和HEAD以及heAD等是一个意思 3.H5 狭义- HTML的第五大版本HTML5 广义- HTML5+CSS3+JavaScript HTML文件结构(一个HTML文件就是一个网页)：一个HTML标签代表整个网页，head负责 头部部分和网页设置，body负责网页内容的显示 4.HTML语法：HTML中的所有代码都是由一个一个的标签组成的 单标签 &lt;标签名 属性名1=值1 属性名2=值2 属性名3=值3 …&gt; 或者 &lt;标签名 属性名1=值1 属性名2=值2 属性名3=值3 … /&gt; 它们分别是一个单标签 双标签 &lt;标签名 属性名1=值1 属性名2=值2 属性名3=值3 …&gt; 标签内容 &lt;/标签名&gt; 说明：&lt;&gt; - &lt;&gt;以及&lt;&gt;中的/都是固定写法标签名 - 不能自己随便命名，必须是HTML提供的标签名才可以用 注意：标签名的前后不能随便加空格，标签名前一定不能加空格！ 属性 - 以’属性名=值’的形式出现在开始标签或者单标签中，多属性之间用空格隔开，属性出现的顺序不会影响结果 标签内容 - 只有双标签才有标签内容；标签的内容可以是文字，也可以是其他一个或多个标签，还可以是标签和文字的组合 注意：哪些标签是单标签，哪些是双标签是确定的 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;!--基本结构--&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;!--设置网页标题--&gt; &lt;title&gt;❤❤小王❤❤&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--heading 标题--&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;h2&gt;我的第二个标题&lt;/h2&gt; &lt;!--program 段落--&gt; &lt;p&gt;我的第一个段落&lt;/p&gt; &lt;!--网页链接--&gt; &lt;a href=\"http://www.baidu.com\"&gt;百度首页&lt;/a&gt; &lt;hr&gt; &lt;img src=\"https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2203847359,795030512&amp;fm=15&amp;gp=0.jpg\" width=\"400\" height=\"300\"/&gt; &lt;/body&gt;&lt;/html&gt; ###head里面的标签1.meta标签 — 设置网页原数据2.title标签 — 设置网页标题3.link标签 — 导入文件(设置网页图标，导入样式表)4.style标签 — 样式标签，写css代码5.script标签 — 导入js代码标签 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- charset属性 - 设置网页中文本编码格式 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;小可爱专属&lt;/title&gt; &lt;!--设置网页图标 rel属性 - 导入的文件的作用： \"stylesheet\" - 样式表 \"icon\" - 图标 type属性 - 导入文件类型：文件类型/文件后缀 \"text/css\" - 是后缀是CSS的文本文件 \"image/jpg\" - 是后缀是jpg的图片文件 href属性 - 导入文件的路径 --&gt; &lt;link rel=\"icon\" type=\"image/png\" href=\"./img/心.png\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; body里的标签123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;body标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1.标题标签：h1~h6 》》》 注意：如果文字本身的意义本身就是标签是，才用h标签 --&gt; &lt;h1&gt;我是第一标签&lt;/h1&gt; &lt;h2&gt;我是第二标签&lt;/h2&gt; &lt;!--2.段落标签：p 》》》》注意：一个段落一个p标签 --&gt; &lt;p&gt;&amp;emsp;&amp;emsp;10月8日上午消息，天眼查数据显示，近日，百度云计算技术（北京）有限公司发生变更，百度创始人李彦宏卸任执行董事。同时，刘辉卸任总经理一职，新增崔珊珊为总经理、执行董事。&lt;/p&gt; &lt;br /&gt; &lt;hr /&gt; &lt;p&gt;&amp;emsp;&amp;emsp;另外，百度云计算技术（北京）有限公司的法定代表人也发生变更，刘辉退出，由崔珊珊接任。&lt;/p&gt; &lt;!--3.文本相关特殊符号和标签 br标签 - 强行换行 &amp;nbsp;符号、&amp;emsp;符号 - 一个&amp;nbsp代表一个像素，一个&amp;emsp代表一个空格 hr标签 - 水平分割线 --&gt; &lt;!--4.段落标签：font 表示单行文字 --&gt; &lt;font&gt;hello world&lt;/font&gt; &lt;!--5.字体相关的标签 加粗：b标签\\strong 倾斜：i标签\\em 注意加粗和倾斜可以两两嵌套使用 --&gt; &lt;p&gt;软银创始人兼首席执行官&lt;strong&gt;孙正义&lt;/strong&gt;（Masayoshi Son）在一次采访中，公开表示支持WeWork。他说，&lt;b&gt;&lt;em&gt;10年&lt;/em&gt;&lt;/b&gt;之内，这家公司将“实现可观的盈利”。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 列表标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;前锋学科&lt;/p&gt; &lt;!--1.无序列表：ul-li标签 ul标签 - 代表整个列表(容器) li - 提供列表元素 --&gt; &lt;ul&gt; &lt;li&gt;python&lt;/li&gt; &lt;p&gt;&amp;emsp;&amp;emsp;简单的编程语言&lt;/p&gt; &lt;li&gt;web前端&lt;/li&gt; &lt;li&gt;软件测试&lt;/li&gt; &lt;li&gt;嵌入式&lt;/li&gt; &lt;/ul&gt; &lt;!--有序列表：ol-li ol - 代表整个列表 li - 代表列表元素 --&gt; &lt;p&gt;水煮鱼的做法&lt;/p&gt; &lt;ol&gt; &lt;li&gt;放鱼&lt;/li&gt; &lt;li&gt;放辣椒&lt;/li&gt; &lt;li&gt;完成&lt;/li&gt; &lt;/ol&gt; &lt;!--自定义列表：dl-dt-dd dl - 代表整个大容器 dt - 分类名 dd - 每个分类下的元素 --&gt; &lt;p&gt;宠物&lt;/p&gt; &lt;dl&gt; &lt;dt&gt;鸟类&lt;/dt&gt; &lt;dd&gt;布谷鸟&lt;/dd&gt; &lt;dd&gt;杜鹃&lt;/dd&gt; &lt;dt&gt;狗类&lt;/dt&gt; &lt;dd&gt;边牧&lt;/dd&gt; &lt;dd&gt;哈士奇&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt;&lt;/html&gt; ####图片标签和超链接标签 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;#down&quot;&gt;跳到底部&lt;/a&gt; &lt;br /&gt; &lt;!--1.图片标签：img标签 单标签 src属性 - 提供图片路径；路径可以是本地地址，也可以是网络地址 title属性 - 设置图片标题 alt属性 - 图片加载失败后显示的信息 --&gt; &lt;img src=&quot;img/心.png&quot; width=&quot;200&quot; height=&quot;200&quot; title=&quot;爱你&quot; alt=&quot;图片加载失败&quot; id=&quot;top&quot;/&gt; &lt;br /&gt; &lt;img src=&quot;img/花.png&quot;/&gt; &lt;!--2.超链接：a标签 href属性 - 跳转的网页地址 a.网络地址 b.本地HTML文件地址(绝对和相对) c.选择器，完成页面内跳转 target属性： _self() - 在当前页面中刷新出新的页面(不会产生新的窗口) _blank - 在新的页面中刷新新的页面(会产生新的窗口) --&gt; &lt;!--文本超链接--&gt; &lt;a href=&quot;https://user.qzone.qq.com/1092824310/infocenter&quot;&gt;我们的相册&lt;/a&gt; &lt;!--图片超链接--&gt; &lt;br /&gt; &lt;a href=&quot;https://user.qzone.qq.com/1092824310/infocenter&quot;&gt; &lt;img src=&quot;img/心.png&quot;/&gt; &lt;/a&gt; &lt;a href=&quot;#p1&quot;&gt;第一章&lt;/a&gt; &lt;a href=&quot;#p2&quot;&gt;第二章&lt;/a&gt; &lt;a href=&quot;#p3&quot;&gt;第三章&lt;/a&gt; &lt;p id=&quot;p1&quot;&gt;第一章&lt;/p&gt; &lt;img src=&quot;img/2.png&quot;/&gt; &lt;p id=&quot;p2&quot;&gt;第二章&lt;/p&gt; &lt;img src=&quot;img/1.png&quot;/&gt; &lt;p id=&quot;p3&quot;&gt;第三章&lt;/p&gt; &lt;img src=&quot;img/心.png&quot;/&gt; &lt;br /&gt; &lt;a href=&quot;#top&quot; id=&quot;down&quot;&gt;回到顶部&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; ####表单标签和input标签 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1.表单标签：form form标签单独用没有意义，主要用在将部分用户信息收集相关标签中的内容做整体提交和重置用的 action属性 - 提交路径(接口) methon属性 - 请求方式 --&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;!--2.input标签 单标签 type属性 - 决定标签类型 ① text 文本输入框 value属性 - 输入框中的内容 name属性 - 区分和提交不同的输入框，如果不设置name值，数据是不会提交的。 ② password 密文输入框 value属性 - 输入框中的内容 name属性 - 区分和提交不同的输入框，如果不设置name值，数据是不会提交的。 ③ radio 单选按钮 value属性 -表示被选中的数据值，不会被显示 name属性 - 区分和提交(注意：同一组选项的name属性必须一致) checked属性 - 设置为checked默认选中 ④checkbox 复选按钮 value属性 -表示被选中的数据值，不会被显示 name属性 - 区分和提交(注意：同一组选项的name属性必须一致) checked属性 - 设置为checked默认选中 ⑤button 普通按钮 value属性 -显示内容 ⑥reset 重置按钮 会自动重置所处form里面的所有内容 value属性 ⑦submit 提交按钮 点击后会自动将当前form标签中设置了name属性的标签， 以name=value的形式将数据以指定的方式和路径进行提 交 --&gt; &lt;font&gt;账号： &lt;/font&gt;&lt;input type=\"text\" name=\"user-name\" id=\"\" value=\"\" placeholder=\"输入账号\"/&gt;&lt;br /&gt;&lt;br /&gt; &lt;font&gt;电话： &lt;/font&gt;&lt;input type=\"text\" name=\"tel\" id=\"\" value=\"\" placeholder=\"输入电话\"/&gt;&lt;br /&gt;&lt;br /&gt; &lt;font&gt;密码： &lt;/font&gt;&lt;input type=\"password\" name=\"password\" id=\"\" value=\"\" placeholder=\"输入密码\"/&gt;&lt;br /&gt;&lt;br /&gt; &lt;font&gt;性别&lt;/font&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" id=\"g1\" checked=\"checked\"/&gt;&lt;label for=\"g1\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"女\" id=\"g2\" /&gt;&lt;label for=\"g2\"&gt;女&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;font&gt;兴趣&lt;/font&gt; &lt;input type=\"checkbox\" name=\"ball\" id=\"ball1\" value=\"乒乓球\" /&gt;&lt;label for=\"ball1\"&gt;乒乓球&lt;/label&gt; &lt;input type=\"checkbox\" name=\"ball\" id=\"ball2\" value=\"羽毛球\" /&gt;&lt;label for=\"ball2\"&gt;羽毛球&lt;/label&gt; &lt;input type=\"checkbox\" name=\"ball\" id=\"ball3\" value=\"蓝球\" /&gt;&lt;label for=\"ball3\"&gt;蓝球&lt;/label&gt; &lt;input type=\"checkbox\" name=\"ball\" id=\"ball4\" value=\"足球\" /&gt;&lt;label for=\"ball4\"&gt;足球&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"普通按钮\" /&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;input type=\"reset\" name=\"\" id=\"\" value=\"重置\" /&gt; &lt;/form&gt; &lt;!--补充 button标签 --&gt; &lt;br /&gt; &lt;br /&gt; &lt;button&gt;&lt;img src=\"img/心.png\" height=\"35\" width=\"38\"/&gt;&lt;p&gt;爱心&lt;/p&gt;&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 表格标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;小可爱相册&lt;/title&gt; &lt;link rel=\"icon\" type=\"image/png\" href=\"./img/心.png\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1.表格标签：table-tr-td table标签 - 代表表格整体 1.border属性 - 边框的宽度 2.cellspacing属性 - 设置单元格间隙，默认不为0 3.bordercolor属性 - 边框的颜色，直接写颜色单词或者#000000~#ffffff 4.cellpadding属性 - 设置所有单元格内容和单元格边框之间的间距，默认为0 5.width属性 - 6.height属性 - 设置整个表格的宽度 7.bgcolor属性 - 设置整个表格的背景颜色 8.align属性 - 设置整个表格的对齐方式，left center right，表示表格放的位置 tr标签 - 代表一行 - 设置整个表格的高度 1.height属性 - 设置行的高度 2.align属性 - 设置当前行中所有的内容的对齐方式 td标签 - 代表一个单元格 1.width属性 - 设置一列的宽度 2.align属性 - 设置当前单元格中所有的内容的对齐方式 --&gt; &lt;table border=\"2\" bordercolor=\"#dfdfdf\" cellpadding=\"10\" cellspacing=\"0\" bgcolor=\"cornsilk\" align=\"center\"&gt; &lt;tr height=\"20\" bgcolor=\"#aaaaaa\" align=\"center\"&gt; &lt;td width=\"40\" bgcolor=\"white\"&gt; &lt;a href=\"https://www.baidu.com\"&gt; &lt;img src=\"img/心.png\"/&gt; &lt;/a&gt; &lt;/td&gt; &lt;td width=\"80\"&gt;2&lt;/td&gt; &lt;td width=\"40\"&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"20\" bgcolor=\"aqua\" align=\"center\"&gt; &lt;td&gt;4&lt;/td&gt; &lt;td bgcolor=\"red\"&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40\" align=\"center\"&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;!--复杂表格 colspan - 列合并 rowspan - 行合并 --&gt; &lt;table border=\"2\" cellspacing=\"0\" cellpadding=\"10\" width=\"200\" height=\"400\"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td rowspan=\"3\" colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan=\"2\" colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;table border=\"1\" cellspacing=\"0\" bgcolor=\"aqua\" width=\"400\"&gt; &lt;tr height=\"30\"&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan=\"3\" colspan=\"2\"&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"30\"&gt; &lt;td rowspan=\"2\" colspan=\"2\"&gt;&lt;/td&gt; &lt;td rowspan=\"2\"&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"30\"&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"30\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"30\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; ####下拉菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--1.下拉菜单 select标签 - 表示整个列表、 option标签 - 列表中的选项 --&gt; &lt;select name=\"所在城市\"&gt; &lt;option value=\"成都\"&gt;成都&lt;/option&gt; &lt;option value=\"重庆\"&gt;重庆&lt;/option&gt; &lt;option value=\"广州\"&gt;广州&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"达州\"&gt;达州&lt;/option&gt; &lt;option value=\"隆昌\"&gt;隆昌&lt;/option&gt; &lt;/select&gt; &lt;!--2.下拉列表选项分组：select - optgroup - option --&gt; &lt;br /&gt;&lt;br /&gt; &lt;select name=\"\"&gt; &lt;optgroup label=\"海里面的\"&gt;&lt;/optgroup&gt; &lt;option value=\"\"&gt;鱼&lt;/option&gt; &lt;option value=\"\"&gt;虾&lt;/option&gt; &lt;option value=\"\"&gt;蟹&lt;/option&gt; &lt;optgroup label=\"岸上的\"&gt;&lt;/optgroup&gt; &lt;option value=\"\"&gt;鸡&lt;/option&gt; &lt;option value=\"\"&gt;鸭&lt;/option&gt; &lt;option value=\"\"&gt;鹅&lt;/option&gt; &lt;/select&gt; &lt;!--3.多行文本域：textarea标签 rows属性 - 一个屏幕显示的行数 cols属性 - 一行显示的字数 placeholder - 设置输入框中的占位符 maxlength - 设置最多能输入的字符 disabled - 设置为\"disabled\"禁用，也可以在按钮中使用 --&gt; &lt;br /&gt; &lt;br /&gt; &lt;textarea name=\"content\" rows=\"5\" cols=\"60\" placeholder=\"写入意见\" maxlength=\"200\"&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; END","link":"/2019/10/26/HTML%E5%9F%BA%E7%A1%80/"},{"title":"JS应用","text":"JS是JavaScript的简称，是前端界面比较重要的一个部分，负责动态展示部分 1. 原生JS1.1 DOM操作节点操作 - 获取节点1.直接获取节点 a.通过标签的id值来获取指定的标签: document.getElementById(id值)b.通过标签名来获取指定的标签: document.getElementsByTagName(标签名)c.通过类名来获取指定的标签: document.getElementsByClassName(类名)d.通过name属性的值来获取指定的标签(了解): document.getElementsByName(‘username’) 2.获取父节点 a.获取子节点对应的父节点: 子节点.parentElement 3.获取子节点 a.获取所有的子节点: 父节点.children / 父节点.childNodesb.获取第一个子节点: 父节点.firstElementChildc.获取最后一个子节点: 父节点.lastElementChild 节点操作 - 创建添加和删除1.创建节点: document.createElement(标签名) 2.添加节点: 父节点.appendChild(需要添加的节点) / 父节点.insertBefore(新节点, 指定节点) 3.删除节点: 父节点.removeChild(子节点) / 节点.remove() 4.拷贝节点: 节点.cloneNode() / 节点.cloneNode(true) 5.替换节点: 父节点.replaceChild(新节点, 子节点) 练习: 删除广告、动态添加和删除 作业: 成都汽车限号查询 1.2 BOM操作1.window基本操作 a.打开新窗口：window.open(网页地址) / window.open(‘’,’’,’width=x?,height=y?’) b.关闭窗口: window.close() c.移动当前窗口: 窗口对象.moveTo(x坐标, y坐标) d.获取浏览器的宽度和高度: window.innerWidth, window.innerHeight / window.outerWidth, window.outerHeight 2.弹框 a. alert(提示信息) - 弹出提示信息(带确定按钮) b. confirm(提示信息) - 弹出提示信息(带确定和取消按钮),返回值是布尔值，取消-false, 确定-true c. prompt(提示信息,输入框中的默认值) - 弹出一个带输入框和取消，确定按钮的提示框; 点取消，返回值是null;点确定返回值是输入框中输入的内容 3.定时 a. setInterval(函数,时间) / clearInterval(定时对象) b. setTimeout(函数,时间) / clearTimeout(定时对象) 1.3 事件1.事件绑定 a. 在标签内部给事件源的事件属性赋值 b. 通过节点绑定事件1: 标签节点.事件属性 = 函数 c. 通过节点绑定事件2: 标签节点.事件属性 = 匿名函数 d. 通过节点绑定事件3: 节点.addEventListener(事件名,函数) 2.常见事件类型 a..onload - 页面加载完成对应的事件(标签加载成功) window.onload = 函数 b.鼠标事件: onclick / onmouseover / onmouseout c.键盘事件: onkeypress / onkeydown / onkeyup d.输入框内容改变: ‘onchange’ - 输入框输入状态结束 3.事件捕获 事件对象.stopPropagation() 2. jQuery2.1 基本操作===========节点============= 1.获取节点 $(选择器) console.log($(‘#div2&gt;a’)) //和后代选择器效果一样 console.log($(‘p + a’)) //获取紧跟着p标签的a标签 console.log($(‘#p1~*’)) //获取和id是p1的标签的后面的所有同级标签 console.log($(‘div:first’)) //第一个div标签 console.log($(‘p:last’)) //最后一个p标签 console.log($(‘div *:first-child’)) //找到所有div标签中的第一个子标签 2.创建标签 $(‘HTML标签语法’) ,例如：$(‘我是div‘) 3.添加标签 父标签.append(子标签) - 在父标签的最后添加子标签 父标签.prepend(子标签) - 在父标签的最前面添加子标签 标签.before() 标签.after() 4.删除标签 标签.empty() - 清空指定标签 标签.remove() - 删除指定标签 ==============属性================ 1.普通属性的获取和修改 - 除了innerHTML(html), innerText(text)以及value(val) 标签.attr(属性名) - 获取指定的属性值 标签.attr(属性名, 值) - 修改/添加属性 //2.标签内容属性// 双标签.html()// 双标签.text()// 单标签.val()//注意：上面的函数不传参就是获取值，传参就是修改值 2.class属性 - HTML中一个标签可以有多个class值，多个值用空格隔开 标签.addClass(class值) - 给标签添加class值 标签.removeClass(class值) - 移除标签中指定的class值 3.样式属性 a.获取属性值 标签.css(样式属性名) - 获取样式属性值 b.修改和添加 标签.css(样式属性名, 值) - 修改属性值 标签.css({属性名:值, 属性名2:值2…}) - 同时设置多个属性 ==============事件============= 1.标签.on(事件名,回调函数) - 给标签绑定指定的事件（和js中的addEventLinsenner一样） 事件名不需要要on 2.父标签.on(事件名,选择器,回调函数) - 在父标签上添加事件，传递给选择器对应的子标签 选择器 - 前面标签的后代标签(子标签/子标签的子标签) 2.2 Ajax语法： ​ 1.get请求 ​ $.get(url,data,回调函数,返回数据类型) ​ - url：请求地址（字符串） ​ - data：参数列表 (对象) ​ - 回调函数：请求成功后自动调用的函数(函数名，匿名函数) ​ - 返回数据类型：请求到的数据的格式(字符串，例如：’json’) ​ ​ 2.post请求 ​ $.post(url,data,回调函数,返回数据类型) ​ - url：请求地址（字符串） ​ - data：参数列表 (对象) ​ - 回调函数：请求成功后自动调用的函数(函数名，匿名函数) ​ - 返回数据类型：请求到的数据的格式(字符串，例如：’json’) ​ ​ 3.ajax ​ $.ajax({ ​ ‘url’:请求地址, ​ ‘data’:{参数名1:值1, 参数名2:值2}， ​ ‘type’:’get’/‘post’, ​ ‘dataType’:返回数据类型, ​ ‘success’:function(结果){ ​ 请求成功后要做的事情 ​ } ​ }) 3. Vue.jsvar 变量名 = new Vue({ ​ el: 选择器, ​ data:数据对象, ​ methods:方法对象， ​ computed:计算属性 }) 设置标签内容: 设置标签属性值: v-bind:属性=’Vue属性名’ if语句：v-if=’Vue属性名’ 循环结构：v-for=’变量 in 数组属性’ 绑定事件：v-on:事件名=’函数名’ v-model可是实现 C的内容和属性双向绑定","link":"/2019/10/23/JS%E5%BA%94%E7%94%A8/"},{"title":"continue和break和三目运算符","text":"循环结构部分的continue和break以及Python中的三目运算符 continue1234\"\"\"continue是循环体中的关键字，只能写在循环体中，用的时候直接用。执行循环体的时候如果遇到continue，直接结束本次循环，进入下次循环的判断\"\"\" 1234for x in range(100): if x &amp; 1: continue print(x) break1234\"\"\"break是循环体中的关键字，只能写在循环体中，用的时候直接用。执行循环体的时候如果遇到break，直接跳出最近循环\"\"\" 1234for x in range(100): if x == 50: break print(x) else12345678910\"\"\"for 变量 in 序列： 循环代码段else： 代码段当for循环非自然死亡时(遇到break)，else里面的代码段不会执行。当for循环自然死亡时，else里面的代码段就会执行。自然死亡指循环次数正常进行\"\"\" 1234while 条件语句： 循环代码段else： 代码段 ####补充：python中的三目运算符写法 1234567①C语言中的三目运算符：条件语句?值1：值2 -如果条件语句为True，输出结果就是值1，否则就是值2②python中的三目运算符值1 if 条件语句 else 值2-如果条件语句为True，输出结果就是值1，否则就是值2 123456789101112131415# c语言，判断是否成年include &lt;stdio&gt;main(){ a = (age&lt;18?1:0); if a == 1 { printf(\"you is an unadult man\"); } else { printf(\"you is an adult man\"); } return 0} 1234# python:判断是否成年a = int(input('please input your age number:'))adult = (True if a &gt;= 18 else False)print(adult)","link":"/2019/10/26/continue%E5%92%8Cbreak%E5%92%8C%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"Python中和数字相关的数据类型","text":"Python中和数字相关的数据类型：int、float、bool、complex，也讲到随机数的部分 #####1.Python中和数字相关的数据类型有： ######int、float、bool、complex 1.int(整型)： 1数字中所有整数对应的类型，例如：23, 58, 100 2.float(浮点型)： 1生活中所有小数对应的类型，例如：2.3, 0.22, 2.666, 2.2e100 3.bool(布尔)： 1只有True和False两个值；True本质就是数字1，False本质就是数字0 4.complex(复数): 12包含所有的复数，形如a + bj的数就是复数，j 是虚数单位,j**2 == -110+1j 3-5j 注意：虚部的1不能不写！ #####2.数据类型相关方法 1.type(数据) —获取数据的类型 2.isinstance(数据，类型)—判断指定数据是否是指定类型，返回布尔值。 3.数据类型转换: 类型（数据）—-将数据转换成指定类型 12345678910111213result = int(2.3)print(result, type(result))# -----取整数result = float(2)print(result, type(result))# -----加.0&quot;&quot;&quot;任何数据类型的数据都能转换为bool类型，所有为零或为空的数据(包括None)都会转换为False,其他全为True。bool(数据)&quot;&quot;&quot; #####3.随机数 随机挑选 123# 随机挑选random.choice(序列) ---在序列中随机返回一个数据。range(M,N,step_size) ---从M开始,每次+step_size,直到N-1为止 1234# 随机浮点数random.random() ---随机返回0~1的浮点数random.random()*100 ---随机返回0~100的浮点数random.random()*10 + 10 ---随机返回10~20的浮点数 1234# 打乱顺序list1 = [1,2,3,4,5,6,7,8,9]random.shuffle(list) # --将序列中的元素随机排列(序列必须是可变的)print(list1) 123# 随机浮点数result = random.uniform(10,60) # 产生[10,60]的随机浮点数，10和60都能取到print(result) 12# 随机整数# random.randint(1,10) -- 产生[1~10]的随机整数，1和10都能取到 1234567891011121314151617181920# 猜数字游戏import randomnum = random.randint(1, 101)sum1 = 10while True: if sum1 == 0: print('机会用完了，抱歉，你失败了！') break else: print('你有%d次机会' % sum1) play_num = int(input('please input a number:')) if play_num == num: print('success!') break else: sum1 -= 1 if play_num &lt; num: print('the number is small!') else: print('the number is big!')","link":"/2019/10/26/Python%E4%B8%AD%E5%92%8C%E6%95%B0%E5%AD%97%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"git常用指令","text":"这里面是关于git的一些基本语法 分类: -python基础后期 1.基本指令git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 新建git仓库git add 文件/文件夹 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 将文件添加到缓存区中git add -A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中git status &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——— 查看git状态git commit -m ‘提交信息’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 将缓存区中的内容全部提交到git本地仓库中 git log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——- 查看提交日志 git reset -- hard HEAD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 让工作目录中的内容和仓库中的内容保持一致git reset --hard HEAD^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到上一个版本git reset -- hard 版本号 —— 回到指定的版本git checkout 文件名 —— 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone &lt;url&gt; - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git remote add origin 地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次) git push [-u] origin master —– 提交(-u在第一次提交分支的时候才用) git push — 将本地仓库的内容提交到远程仓库master分支上 git push origin 分支名 — 将本地仓库的内容提交到远程仓库对应的分支上, 如果分支不存在会自动创建 git pull — 将远程仓库中的内容更新到本地仓库和工作区中 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] - 查看分之git branch 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之git checkout 分支名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 切换分之git checkout -b 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 切换并创建新的分之git diff 分之1 分之2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异git merge 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean 怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)","link":"/2019/10/23/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"python基础语法","text":"python是一门简单的解释型语言，这里讲大概的基础语法 1.python基础语法python 的运行（无开发工具）：可在终端输入 python py文件路径pycharm的使用快捷键：12345678910①Ctrl + S --保存②Ctrl + / --添加注释或取消注释③Ctrl + A --全选④Ctrl + C --复制⑤Ctrl + V --粘贴⑥Ctrl + X --剪切⑦Ctrl + Shift + Z --反撤销⑧Ctrl + Z --撤销⑨alt + mouse --多光标⑩shfit + mouse --连续选择多行 第一行代码print是python中的打印函数，功能是将括号中的内容在控制台打印出来1print(&apos;Hello World&apos;) 语法注释：在代码中不参与编译（不影响程序的功能），对代码进行注解和说明。12①单行注释：在注释文字之前加一个 #②多行注释：用三个&quot;或三个&apos;括起来的注释文字 语句：每一条代码就是一条语句Python代码的规范参照 PEP8规范 python对语句的要求，一般一条语句占一行，一条语句结束时不用写分号; 除非一行有多条语句，则必须加分号;来隔开。 如果一条语句的长度超过规范，则在换行字符前加 \\ 即可换行显示 缩进四个空格代表一级缩进 123a = 1if a is 1: print('a = 1') 123IndentationError : unexpected indent --表示代码缩进错误（多加缩进）IndentationError: expected an indented block --表示代码缩进错误（少加缩进） 标识符标识符是在程序中给变量、函数或者类、对象等命名用的。①要求：由字母、数字、下划线组成，且不能以数字开头。②关键字：在python中具有特殊功能和特殊意义的标识符就是关键字。 关键字只能用为本身功能 Python关键字一览表 False None True and as assert break class continue def elif or while in for is lambda not global nonlocal raise from yield finally with pass del ##### 常用数据 123456789①数字数据：用来表示大小、多少的数据；分为整形（整数）和浮点型（小数）。②文本数据：用来表示文本的数据；对应的数据类型是字符串。③布尔值：只有True或者False，分别表示真（肯定）或假（否定）④复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。⑤其他数据：列表，字典，集合，元祖，函数，自定义类... 输入和输出函数①输出函数：print（内容） 1234567891011print(800)print(' hello world ')print(True)a = 1print(a)print(800, 900, 102.2, 'internet')# print默认打印完一行后会自动换行，但是可以设置end的值来定制内容结束的打印# print(需要打印的内容，end = '结束后打印的内容')print(800, end = ' ') # 打印后不换行# sep的使用 ''中写分隔符号print(800,900,100,sep = ' ') ②输入函数 input() 123# input 会从键盘获取输入值，并返回值，返回值为字符串文本数据str = input(&apos;请输入一段字符&apos;)print(str) 2.进制1.什么是进制？ 一个数值的不同书写方式 2.常用进制 十进制，二进制，八进制，十六进制 ①十进制 写法：110 基数 0,1,2,3,4,5,6,7,8,9 进位 逢10进1 位权 110 = 1*10^2 + 1*10^1 + 0*10^0 ②二进制 写法：0b110或者0B110| 基数 | 0,1 || :–: | :—————————–: || 进位 | 逢2进1 || 位权 | 110 = 1*2^2 + 1*2^1 + 0*2^0 | ③八进制 写法：0o110或者0O110 基数 0,1,2,3,4,5,6,7 进位 逢8进1 位权 110 = 1*8^2 + 1*8^1 + 0*8^0 ④十六进制 写法：0x110或者0X110| 基数 | 0,1,2,3,4,5,6,7,8,9,a(A),b(B),c(C),d(D),e(E),f(F) || :–: | :————————————–: || 进位 | 逢16进1 || 位权 | 110 = 1*16^2 + 1*16^1 + 0*16^0 | 3.进制转换 十进制变为其他进制：用十进制数除其他进制的位权取余数，除到商为0为止，最后余数往前写就是其他进制。 其他进制转十进制：基数*位权的乘积就是十进制 二进制转八进制：3位二进制转1位八进制 二进制转十六进制：4位二进制转1位十六进制 4.转换方式(bin\\oct\\hex) 其他进制转十进制：直接print打印，即可将其他进制换算为对应的十进制 其他进制转二进制 输入bin(1000)或者bin(0xaf)或者bin(0o55) 其他进制转八进制 输入oct(1000)或者oct(0xaf)或者oct(0b01) 其他进制转十六进制 输入hex(1000)或者hex(0o77)或者hex(0b11) 3.原码、反码、补码1.计算机存储数据 计算机只能直接存数据，而且存的数据是数字的补码 符号位：数字转化为二进制后最高位为符号位，0为正，1为负 真值：数字部分的二进制值 12345678910111213计算机内存单位位(bit)1字节(byte) = 8位1KB = 1024byte1MB = 1024KB1GB = 1024MB1TB = 1024GB 正数| 原码 | 符号位+真值 | 01011010 || :–: | :—-: | :——: || 反码 | 与原码相同 | 01011010 || 补码 | 与原码相同 | 01011010 || 十进制 | | 90 |负数| 原码 | 符号位+真值 | 11011010 || :–: | :———–: | :——: || 反码 | 符号位不变，其他位按位取反 | 10100101 || 补码 | 反码+1 | 10100110 || 十进制 | | -90 | 计算机存储数据为什么存补码？ 计算机中没有减法器，只有加法器。导致负数原码参与运算的时候出错。 作业10.写代码获取数字n=1234中每一位上的数 12345n = 1234print('千位：', n//1000)print('百位：', n % 1000//100)print('十位：', n % 1000 % 100//10)print('个位：', n % 10) 11.写代码统计一个任意整数m是几位数，并且逆序打印出每一位数字。（0基础不做, 不能用字符串来做） 例如: m=123, 打印： m是3位数 3 2 1 ​ m=45321, 打印：m是5位数 1 2 3 5 4 12345678910m = int(input('请输入一个整数:'))n = m #暂存输入的值num = 0while( m != 0): x = m % 10 # 取个位数 print(x, end=' ') m = (m - x)//10 # 减去个位数之后除以10，通过循环可以得到新的个位数 num = num + 1 # 统计位数print('\\n')print('输入的%d是个%d位数' % (n, num)) 12345输入两个数字就是 m, n = map(int, input().split())三个及三个以上就和两个的类似: a, b, c = map(int, input().split())","link":"/2019/10/26/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"socket网络编程","text":"本文简单的讲述Python中socket网络编程 ​ socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 ​ 套接字编程 —— 给予传输层提供的传输服务来构建自己的网络应用套接字是操作系统提供的一套网络编程接口（函数），可以通过套接字编程来调用传输层甚至是IP层（寻址和路由）提供的传输服务 python中用socket函数创建套接字： ​ 语法：*socket.socket(family=,type=) * ​ 说明： family: 套接字家族可以使哪种形式的地址：AF_UNIX或者AF_INET（代表IPv4）、AF_INET6（代表IPv6） type: 套接字类型使用哪种传输服务：SOCK_STREAM 代表 TCP或SOCK_DGRAM 代表 UDP protocol: 一般不填默认为0. ####1.服务器端套接字内建方法： ######第一步：创建服务器套接字对象 socket.socket(family=, type=) 12server = socket(family=AF_INET, type=SOCK_STREAM)# 指定使用哪种形式的地址和传输服务 ######第二步：绑定服务器IP地址和端口 ​ 端口的取值范围：0-65535，建议使用1024以上的端口 ​ 注意：同一个IP地址可以绑定多个不同的服务，端口就是用来区分这些服务的 套接字.bind('IP地址',端口) 1server.bind(('10.7.185.98', 3333)) ######第三步：监听连接（等待其他的程序连接到该服务） 套接字.listen(程序最大排队等待数) 1server.listen(511) # 排队等待 ######第四步：接收连接到服务的客户端（返回一个二元组：（客户端,客户端IP地址）） 客户端,客户端IP地址 = 套接字.accept() 12client, addr = server.accept()print(f'{addr}成功！') ######第五步：给客户端发送数据 注意：对于一个请求可以启动一个线程或一个进程来受理这个请求，这样才不会因为一个请求可能耗费比较多的时间而导致其他的请求被阻塞 客户端.send(发送的数据) 12345with open('./sol.png', 'rb') as f1: content = f1.read() size = len(content)client.send(str(size).encode())client.send(content) ####2.客户端套接字内建方法： ######第一步：创建客户端套接字 socket.socket(family=, type=) 12client = socket(family=AF_INET, type=SOCK_STREAM)# client就是客户端套接字对象 ######第二步：连接到服务器 客户端套接字.connect(('服务器IP地址'，端口)) 12client.connect(('10.7.185.98', 3333))# 客户端连接到服务器 ######第三步：客户端接收数据（每次接收1024），用循环接收大文件 客户端套接字.recv(1024) 可以先接收大文件的大小信息，判断循环终止的条件 12345678data = client.recv(1024)total, size = 0, int(data.decode())with open('./yua.png', 'wb') as files: while total &lt; size: # 接收文件的内容 data = client.recv(1024) f2 = files.write(data) total += 1024 ######第四步：客户端主动跟服务器断开连接 客户端套接字.close() 补充：格式化字符串的新方法,这样的写法更优美 12变量m = nf'{变量m}字符串' 12name = '小花'print(f'我的名字是{name}')","link":"/2019/10/26/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"title":"元组","text":"元组就是不可变的列表。(元组中没有增删改，也没有 ‘列表.’ 相关的方法，其他元组和列表是一样的) ####元组 1.什么是元组(tuple) 元组就是不可变的列表。(元组中没有增删改，也没有 ‘列表.’ 相关的方法，其他元组和列表是一样的) —-将()作为容器的标志，多个元素用,隔开： (元素1,元素2,元素3,…) 元祖是不可变的，有序的 2.元素的要求:和列表一样，同一元组中元素的类型可以不一样。 123456789101112131415161718①只有一个元素的元组tuple1 = (1,)print(tuple1, type(tuple1)) -----&gt; (1,) &lt;class &apos;tuple&apos;&gt;②元组的特殊赋值,可直接用逗号将多个数据隔开，表示一个元组tuple1 = 1, 2, 3print(tuple1,type(tuple1)) -----&gt; (1, 2, 3) &lt;class &apos;tuple&apos;&gt;③获取元组的元素:除了遍历和切片，还可以让变量的个数 = 元组元素的个数point = (100, 200)x, y = pointprint(x, y) ----------&gt;100 200# 用多个变量分别获取元素的时候，在一个变量前加*(这个变量就会成为列表)；# 这个时候变量个数就可以小于元素的个数。取的时候先让没有*的变量去取对应的元素，剩下的元素作为带*的变量的元素。students = (&apos;tom&apos;, 58, 99, 88, 77, &apos;man&apos;, 180)name, *scores, sex, height = studentsprint(name,scores,sex,height) -----&gt; tom [58, 99, 88, 77] man 180 ####字典 1.什么是字典(dict) 字典是容器型数据类型(序列),将{}作为容器的标志，多个元素用 , 隔开 字典中的元素必须是键值对的形式存在的 key:value key ——&gt;不可变的、唯一，一般使用字符串当做key value ——&gt;任何类型的数据都可以，并不唯一 2.字典的增删改查 123456①查 - 获取键值对的值a.获取指定key对应的值： ---- 字典[key] 或者 字典.get(key)/字典.get(key,默认值)dog1 = {&apos;name&apos;:&apos;jody&apos;, &apos;age&apos;:3, &apos;color&apos;:&apos;pink&apos;,&apos;breed&apos;:&apos;土狗&apos;}print(dog1[&apos;color&apos;]) -----&gt;如果key不存在，程序会报错print(dog1.get(&apos;name&apos;)) -----&gt;如果key不存在，程序不会报错，返回默认值，没有默认值就返回None 1234②遍历字典就是把字典放在for in后面 -----&gt;取到的是字典所有的keyfor key in 字典: 循环体 12345678dog1 = {&apos;name&apos;:&apos;jody&apos;, &apos;age&apos;:3, &apos;color&apos;:&apos;pink&apos;,&apos;breed&apos;:&apos;土狗&apos;}for key in dog1: print(key,dog1[key])输出结果：name jodyage 3color pinkbreed 土狗 12345678不推荐的遍历写法：①for value in dog1.values(): print(value)②for key,value in dog1.items(): print(key,value) 2.增和改 123字典[key] = 值如果key不存在，就会在字典中追加新的key，给它的值就是对应的输入值。如果key存在，就会修改key对应的值。 3.删 12a. del 字典[key] ----删除指定key对应的键值对b. 字典.pop(key) ----取出字典中指定key对应的值 123456dog1 = {&apos;name&apos;:&apos;jody&apos;, &apos;age&apos;: 3, &apos;color&apos;: &apos;pink&apos;,&apos;breed&apos;: &apos;土狗&apos;}for x in dog1: if x == &apos;name&apos;: del dog1[x] breakprint(dog1)","link":"/2019/10/26/%E5%85%83%E7%BB%84/"},{"title":"内存管理和拷贝","text":"讲述的是Python中的内存管理机制和深拷贝与浅拷贝的区别 内存的管理内存的管理分为内存的开辟和内存的释放 1.内存的开辟12345678910&quot;&quot;&quot;内存分为栈区间和堆区间，Python中所有数据都是保存在堆区间的，栈区间中保存储存数据地址的变量。每次需要一个数据的时候，python自动去堆区间开辟新的空间；原则上只要需要数据就会开辟一个新空间，哪怕数据和之前的数据是相等的也会重新开辟；但是数字和字符串特殊，每次给数字和字符串开辟空间之前，会检查这个数据内存是否存在，如果存在就直接使用之前储存的数据，如果没有就开辟新空间。&quot;&quot;&quot; 2.内存的释放12345678910&quot;&quot;&quot;Python中内存释放采用的是垃圾回收机制当数据(堆中)的引用计数为0的时候，数据就会被自动销毁(被回收)引用：保存对象的地址的数据就是这个对象的引用增加引用计数:让更多数据储存数据的地址减少引用计数：删除引用；让引用保存别的数据的地址注意：python中针对数据的循环引用已经做了特殊处理，程序员不用再写额外的代码去处理循环引用&quot;&quot;&quot; 12345678910111213141516def main(): print(&apos;==========内存开辟===========&apos;) a = 1 b = 1 print(a is b) print(id(a), id(b)) print(&apos;==========内存释放===========&apos;) c = [] print(getrefcount(c)) if __name__ == &apos;__main__&apos;: main()else: pass 深拷贝和浅拷贝1# 面试题：说说Python中，直接赋值、浅拷贝、深拷贝之间的区别。 12# 1.直接赋值：用一个变量给另外一个变量赋值，赋的就是地址。赋# 值后数据只有一个，两个变量相互影响。 浅拷贝和深拷贝1234&quot;&quot;&quot;列表切片、列表.copy()、字典.copy()等都属于浅拷贝copy模块中的copy，可以拷贝任何数据&quot;&quot;&quot; 123456789101112131415def main(): print(&apos;====直接赋值====&apos;) a = [] b = a.copy() print(id(a), id(b)) print(&apos;====浅拷贝====&apos;) c = Person(&apos;wang&apos;, 18) d = copy.copy(c) d.name = &apos;tang&apos; print(c, d) print(&apos;====深拷贝====&apos;) a1 = Person(&apos;wang&apos;, 18) b1 = copy.deepcopy(a1) b1.name = &apos;tang&apos; print(a1, b1) 区别1234567&quot;&quot;&quot;不管是浅拷贝还是深拷贝，赋值的时候都是先复制原数据产生一个新的数据，然后将新的数据的地址给变量原数据中如果有对象(除了数字和字符串的其他数据)，浅拷贝是直接复制地址，而深拷贝是将地址的值指向的数据复制其数据，产生一个新的数据地址&quot;&quot;&quot; 123456789101112131415161718list1 = [1, 2, &apos;jack&apos;] list2 = copy.copy(list1) list3 = copy.deepcopy(list1) print(list1, list2, list3) print(&apos;=========深浅的区别=========&apos;) a = [1, 2] b = [1, 2, a] c = copy.copy(b) d = copy.deepcopy(b) print(b, c, d) a.append(10) print(b, c, d)if __name__ == &apos;__main__&apos;: main()else: pass","link":"/2019/10/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%B7%E8%B4%9D/"},{"title":"函数补充","text":"函数的进阶部分，大概讲的函数的返回值，匿名函数和递归函数 ###返回值 ####1.什么是返回值？ 作用：将函数内部的数据传递到函数外面 什么是返回值—&gt;就是return后面的值(怎么确定返回值)；就是函数调用表达式的值(怎么获取返回值) 12345a.return：return是函数体中的关键字 作用：1.返回返回值(确定函数返回值) return 表达式 - 表达式的值就是函数的返回值。 2.结束函数，执行函数体的时候，如果遇到return，直接结束函数 b.函数调用表达式：调用函数的语句 ####2.怎么确定函数的返回值 1看在执行函数体的时候能不能遇到return，遇到了返回值就是return后面的值，如果没遇到，返回值就是None。 ####3.怎么获取函数的返回值 1获取函数调用的表达式的结果就可以了 ####多个返回值 1Python中支持一个函数有多个返回值：return 值1，值2，值3... ###初学者确定函数返回值的方式： 1看实现函数的功能会不会产生新的数据，一般将新的数据作为返回值返回。 ###变量的作用域 变量的作用于指的是变量可使用的范围 123456①全局变量：没有声明在函数里或类里面的变量就是全局变量。从声明开始到文件结束，任何地方都可以使用。②局部变量：声明在函数里的变量就是局部变量。只能在函数里面使用，从声明开始到函数结束。③为什么局部变量不能在函数外面使用？ 当调用函数的时候，系统会自动为这个函数在栈区间开辟一个临时的内存区域，用来保存在函数中声明的变量(形参也是)；当函数调用结束之后，这个临时的内存区域会自动销毁，所以里面的变量也会消失。 ####global和nonlocal 这两个只能在函数体中使用 #####global (必须掌握) 1在函数中声明/修改全局变量，就在变量赋值前加&apos;global 变量名&apos;。 #####nonlocal 1想在局部的局部中修改局部变量的值，就在变量赋值前加&apos;nonlocal 变量名&apos;。 ###匿名函数 ####什么是匿名函数 1匿名函数就是没有名字的函数，本质还是函数。除了声明的语法和普通函数不同，其他都一样。 ####声明匿名函数 12345678910①语法lambda 形参列表:返回值②说明lambda ---&gt; 关键字，固定格式形参列表 ---&gt; 和普通函数的形参列表一样: ---&gt; 固定写法，后面不需要缩进返回值 ---&gt; 函数体，相当于普通函数中的return注意:参数类型说明不能在匿名函数中使用。 12a1 = lambda x, y: x+yprint(a1(10, 20)) ####匿名函数和普通函数 12匿名函数能做的普通函数也能做，普通函数能做的匿名函数不一定能做。匿名函数的特点是代码简单，但是实现的功能也比较简单。 1234a = lambda year: year % 4 == 0 and year % 100 != 0 or year % 400 == 0b = lambda year: &apos;这是闰年&apos; if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else &apos;这不是闰年&apos;print(a(2021))print(b(2021)) ###递归函数####什么是递归函数 1在函数声明中调用函数本身。循环能做的事情递归都能做(死循环不行)。 ####怎么写递归函数 123①找临界值，让循环结束的条件，在这儿必须让函数结束(return)②找关系，找F(n)和F(n-1)的关系，也就是当次循环和上次循环的关系③假设函数的功能已经实现了，通过F(n-1)去实现F(n)的功能 1234567用递归实现：求斐波那契数列中的第n个数 1, 1, 2, 3, 5, 8, 13, 21...def fibonacci(n): if n == 1 or n == 2: return 1 return fibonacci(n-1)+fibonacci(n-2)print(4) 123456789101112131415161718192021222324&quot;&quot;&quot;用递归实现：n = 3时打印******n = 4时打印**********&quot;&quot;&quot;def print_star(num): if num == 1: print(&apos;*&apos;) return print_star(num-1) print(&apos;*&apos;*num) return print_star(5) 1解决循环问题的时候，能不用递归就不要用，它会消耗额外的内存和CPU资源","link":"/2019/10/26/%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/"},{"title":"分支和循环","text":"分支和循环，分支只有if，循环有for循环和while循环 if分支结构python中的分支结构只有if，没有switch ####1.if的使用 #####1.1 if 1234567891011121314151617\"\"\"①语法if 条件语句： 代码块② 说明if -- 关键字，固定写法条件语句 -- 有结果的表达式，一般结果是布尔值： -- 固定写法代码块 -- 条件语句为True时执行的代码，保持和if有一个缩进的代码(至少有一条代码)③ 执行过程先判断条件语句是否为True，如果是True就执行代码块，不是就不会执行代码块。如果不是布尔值，就转换布尔再判断，所有为0为空的值，全为False，其余全是True。④\"\"\" 12345num = 11if num &gt; 11: print('num &gt; 11')else: print('num &lt;= 11') 123456# 判断奇偶num = 25if num &amp; 1 == 1: print('it is a uneven number!')else: print('it is a even number!') #####1.2 if–else结构 1234567891011121314151617181920\"\"\"①语法if 条件语句： 代码块1else: 代码块2 ② 说明if -- 关键字，固定写法条件语句 -- 有结果的表达式，一般结果是布尔值： -- 固定写法代码块1 -- 条件语句为True时执行的代码，保持和if有一个缩进的代码(至少有一条代码)else --关键字，固定写法代码块2 -- 条件语句为False时执行的代码，保持和else有一个缩进的代码(至少有一条代码)③ 执行过程先判断条件语句是否为True，如果是True就执行代码块1，不是就会执行代码块2。(必执行其中一个代码块)如果不是布尔值，就转换布尔再判断，所有为0为空的值，全为False，其余全是True。\"\"\" 123456# 判断奇偶(优化)num = 25if num &amp; 1: print('it is a uneven number!')else: print('it is a even number!') 123456# 判断是否成年age = 18if age &gt;= 18: print('成年')else: print('未成年') #####1.3 if–elif –else结构 1234567891011121314151617181920212223242526272829303132\"\"\"①语法if 条件语句1： 代码块1elif 条件语句2: 代码块2elif 条件语句3: 代码块3...else: 代码块n ② 说明if -- 关键字，固定写法条件语句1 -- 有结果的表达式，一般结果是布尔值： -- 固定写法代码块1 -- 条件语句1为True时执行的代码，保持和if有一个缩进的代码(至少有一条代码)elif --关键字，固定写法条件语句2 -- 有结果的表达式，一般结果是布尔值代码块2 -- 条件语句2为True时执行的代码，保持和elif有一个缩进的代码(至少有一条代码)else --关键字，固定写法代码块n -- 条件语句为False时执行的代码，保持和else有一个缩进的代码(至少有一条代码)③ 执行过程先判断条件语句1是否为True，如果是True就执行代码块1，不是就会判断条件语句2。判断条件语句2是否为True，如果是True就执行代码块2，不是就会判断条件语句3。...以此类推如果全部条件语句都不成立，就会执行else后的代码如果不是布尔值，就转换布尔再判断，所有为0为空的值，全为False，其余全是True。\"\"\" 12345678910111213141516# 判断分数等级score = 90grade = Noneif score &gt;= 60: if score &gt;= 70: if score &gt;= 80: if score &gt;= 90: print('优秀') else: print('良好') else: print('中等') else: print('一般')else: print('不及格') 或者更好的写法，更容易看懂 123456789101112score = 90grade = Noneif score &lt; 60: print('不及格')elif score &lt; 70: print('一般')elif score &lt; 80: print('中等')elif score &lt; 90: print('良好')else： print('优秀') 练习题 12345678# 判断100-999中的水仙花数for number in range(100, 1000): a = number % 10 #取出个位 b = number // 10 % 10 #取出十位 c = number // 100 #取出百位 water = a ** 3 + b ** 3 + c ** 3 if number == water: print('% d it is a 水仙花数' % number) 12345678# 判断一个数的奇偶，如果是偶数就打印偶数，是奇数就打印奇数。如果能被4整除，打印‘4的倍数’number = int(input('please input a number:'))if not(number &amp; 1): print('%d is a even number !' % number) if not(number % 4): print('%d is a multiple of 4' % number)else: print('%d is a uneven number !' % number) 循环结构—while、for####for循环 12345678910111213141516\"\"\"①语法：for 变量名 in 序列： 循环体 ②说明：for ---关键字，固定写法变量名 ---和声明变量的时候的变量名一样in ---关键字，固定写法序列 ---一种特殊的数据类型，包括字符串、列表、字典、元组、集合；迭代器、生成器、range(范围)： ---固定写法循环体 ---和for保持一个缩进的一条或者多条语句，至少一条；需要被重复执行的语句就作为循环体③执行过程让变量去序列中取值，一个一个的取，取完为止，每取一次值执行一次循环。\"\"\" ####控制循环次数只能通过控制序列中元素的个数来实现 123456'''range函数range(N) --产生一个0~N-1的数字序列；range(5) -&gt; 0,1,2,3,4range(M,N)--产生一个M~N-1的数字序列；range(1, 5)-&gt;,1,2,3,4range(M,N,step) --从M开始，每加上step产生下一个数字，直到N-1为止；range(1, 10，2)-&gt;,1,3,5,7,9''' 1234567# 求1+2+3+...+100的值sum1 = 0for num in range(1, 101): sum1 += numprint(sum1)# 或者用sum来求和print(sum(range(1, 101))) ####while循环 12345678910111213141516&quot;&quot;&quot;①语法：while 条件语句： 循环体 ②说明：while ---关键字，固定写法条件语句 ---任何有结果的表达式，不能是赋值语句：---固定写法循环体 ---和while保持一个缩进的一条或者多条语句，至少一条；需要被重复执行的语句就作为循环体③执行过程先判断条件语句是否为True，如果是True就执行代码块，执行完成后又判断条件语句是否为True，如果为True，再次执行循环体，以此类推，直到条件语句结果为False就不再执行循环语句。如果不是布尔值，就转换布尔再判断，所有为0为空的值，全为False，其余全是True。&quot;&quot;&quot; 12345x = 0n = 5 # 控制循环次数while x &lt; n: print(x) x += 1 123456# 产生一个数字序列start = 100end = 999while start &lt;= end: print(start) start += 1 ####while循环和for循环的选择： 如果循环次数确定，用for循环 如果循环次数不确定，用while循环，死循环只能用while循环 =========================================================","link":"/2019/10/26/%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"title":"列表(list)","text":"列表是容器类数据类型（序列），将[]作为容器的标志，每个元素用逗号隔开。[元素1，元素2，元素3，…] #####1.什么是列表(list) 12345678910\"\"\"①列表是容器类数据类型（序列），将[]作为容器的标志，每个元素用逗号隔开。[元素1，元素2，元素3，...]列表是可变(元素的个数、值和顺序可变)，并且有序(列表一旦确定，列表中元素的顺序就确定)的②列表中的元素任何类型的数据都可以作为列表元素，同一个列表中元素类型可以不一样\"\"\"list1 = [1, '25', True, 1+1j, 36.2] #####2.获取元素 123456789101112131415\"\"\"list = [1, 2, 3]①获取单个元素a.语法: 列表[下标]b.说明:列表 ---结果是列表的表达式，例如：列表数据、储存的列表的变量、结果是列表的运算表达式等[1, 2, 3] or list[] ---固定写法下标 ---列表中每一个元素都有一个下标来表示这个元素在列表中的位置。取值范围是[0~列表长度-1](顺序) 或者 [-1,-列表长度](逆序)列表长度：指的是列表中元素个数.\"\"\" 12345films = [&apos;盗梦空间&apos;,&apos;肖申克的救赎&apos;,&apos;碟中谍&apos;,&apos;这个杀手不太冷&apos;,&apos;小鬼当家&apos;,&apos;速度与激情8&apos;,&apos;惊天魔盗团&apos;]print(films[-2])print(films[2])# 下标不能越界print(films[10]) # IndexError: list index out of range 123456789101112131415161718&quot;&quot;&quot;②获取部分元素(列表切片) ---返回值一定是列表列表[开始下标:结束下标:步长] 取出的元素不能包含结束下标的元素列表[0::2] ---从下标为0开始取，到最后一个元素结束，每+2取一次列表[0:4:2] ---从下标为0开始取，到第4个元素结束，每+2取一次(不包含第4个元素)列表[-1::-1] ---逆序取出每一个元素列表[1:3] ---取出下标1到下标3的元素(不包含下标3的元素)切片变形:列表[开始下标:结束下标] ------&gt; 步长为1列表[:结束下标:] ------&gt; 开始下标为0，步长为1列表[:结束下标:1] ------&gt; 开始下标为0，步长为1列表[:结束下标:-1] ------&gt; 开始下标为-1，步长为-1列表[::1] ------&gt; 列表从第一个取到最后一个列表[::-1] ------&gt; 列表从最后一个取到第一个(逆序)列表[:] ------&gt; 拷贝，复制原列表&quot;&quot;&quot; #####遍历列表： 123456789①直接遍历列表：for 变量 in 列表: pass变量取到的就是列表中的每个元素②通过遍历下标来遍历元素:for index in range(len(列表长度)): 列表[index] ========================================================= ========================================================= #####列表的增删改：(列表的增删改)[https://www.cnblogs.com/zhangyating/p/8127095.html] 123456&quot;&quot;&quot;1.增加元素++++++++++++++++++++++++++++++++++++++++++++++++++++①列表.append(元素) ---&gt; 在列表的最后添加指定元素，不会形成一个新列表，而是在原列表上增加②列表.insert(index,元素) ---&gt; 在下标index前添加指定元素，不会形成一个新列表，而是在原列表上增加③列表.extend(列表1) ---&gt; 在列表的最后添加列表1中的元素，不会形成一个新列表，而是在原列表上增加&quot;&quot;&quot; 123456name_list = [&apos;孙尚香&apos;, &apos;曹操&apos;, &apos;赵云&apos;, &apos;大乔&apos;, &apos;诸葛亮&apos;, &apos;张飞&apos;, &apos;关羽&apos;]print(name_list)name_list.append(&apos;司马懿&apos;)print(name_list)name_list.insert(0, &apos;貂蝉&apos;)print(name_list) 1234567&quot;&quot;&quot;2.删除元素++++++++++++++++++++++++++++++++++++++++++++++++++++①del 列表[下标] ---&gt; 删除下标对应的元素②列表.remove(元素) ---&gt; 删除符合条件的第一个元素③列表.pop() ---&gt; 删除最后一个元素④列表.pop(index) ---&gt; 删除下标为index对应的元素&quot;&quot;&quot; 1234567891011print(&apos;=======================================================&apos;)name_list = [&apos;孙尚香&apos;, &apos;曹操&apos;, &apos;赵云&apos;, &apos;大乔&apos;, &apos;诸葛亮&apos;, &apos;张飞&apos;, &apos;关羽&apos;]print(name_list)del name_list[-2]print(name_list)name_list.remove(&apos;赵云&apos;)print(name_list)name_list.pop()print(name_list)name_list.pop(0)print(name_list) 1234567891011121314# 将列表中的数字元素按从小到大排序输出\"\"\" __author__ = Tang \"\"\"num_list = [1,5,1,25,45,81,5,5,0,4,5,8,215]n = len(num_list)for i in range(n, 2, -1): for j in range(i-1): if int(num_list[j]) &gt; int(num_list[j+1]): num_list[j], num_list[j+1] = num_list[j+1], num_list[j]print(num_list)或者num_list = [1,5,1,25,45,81,5,5,0,4,5,8,215]num_list.sort()print(num_list) 12345&quot;&quot;&quot;3.改元素列表[下标] = 新元素 ---&gt; 将下标对应的元素替换成新元素&quot;&quot;&quot; 12345print(&apos;=======================================================&apos;)name_list = [&apos;孙尚香&apos;, &apos;曹操&apos;, &apos;赵云&apos;, &apos;大乔&apos;, &apos;诸葛亮&apos;, &apos;张飞&apos;, &apos;关羽&apos;]print(name_list)name_list[0] = &apos;黄忠&apos;print(name_list) 12345678910111213141516171819202122232425262728293031# 删除小于60的数(有坑！！！！！！！！！！！！！！！！！！！！！)# 方法1list1 = [30, 56, 78, 91, 67, 21, 34, 59, 70]print(list1)index = 0while index &lt; len(list1): if int(list1[index]) &lt; 60: del list1[i] continue else: index += 1print(list1)# 方法2:这个办法最好！！！！！list1 = [30, 56, 78, 91, 67, 21, 34, 59, 70]temps = list1[:] # 取得原序列的切片for temp in temps: if temp &lt; 60: list1.remove(temp)print(list1)# 方法3list1 = [30, 56, 78, 91, 67, 21, 34, 59, 70]index = 0for _ in range(len(list1)): if list1[index] &lt; 60: del list1[index] continue else: index += 1print(list1) #####3.列表相关运算和操作 1231.数学运算符: +， *① 列表1 + 列表2 -----&gt;将列表2中的元素追加到列表1中，产生一个新的列表。② 列表 * N 或者 N * 列表 ------&gt; 将列表的元素重复N次，形成一个新的列表。 1234567list1 = [1, 2, 3, 4, 5, 6]list2 = [a, b, c, d, c]list3 = list2 * 2print(list3)print(list1 + list2)print(list1)print(list2) 12342.比较运算符：&gt;, &lt;, &gt;=, &lt;=, !=, ==① == 和 != ----&gt;判断两个列表相和不相等(两个列表只有元素的个数、元素的值、元素的顺序都相同，才相等)② 比较大小从列表的第一个元素开始比较，相同后往后比较(注意比较类型要相同) 1233. in 和 not in 的使用元素 in 列表 ----------&gt;判断列表中是否有指定元素，结果是布尔值元素 not in 列表 ----------&gt;判断列表中是否没有指定元素，结果是布尔值 123scores = [50, 60, 55, 99,100, 88, 87, 68, 26, 82]print(50 in scores)print(50 not in scores) 1234567891011124.相关函数① len(序列) ---------&gt;统计序列中元素的个数，但是迭代器和生成器不行。② max() min() ----------&gt;求出序列中的元素的最大值和最小值，但是迭代器和生成器不行注意：序列中的元素类型要一致，并且要支持比较运算符！！！！③ sum(序列) ---------&gt;求序列中所有元素的和，只能是数字序列。求最大值/最小值的套路：先声明一个变量保存最大值(最小值)，默认值是第一个元素，然后取出序列中每个元素依次和保存最大值(最小值)的变量进行比较，如果出现比变量更大(小)的值就更新最大值(最小值)③ list(数据) ---------&gt;将指定的数据转换成列表数据：可以是所有的序列(字符串，range)print(list(100)) ---------&gt;TypeError: &apos;int&apos; object is not iterableprint(list(range(5))) ---------&gt;[0, 1, 2, 3, 4]print(list(&apos;hello&apos;)) ---------&gt;[&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] 123scores = [50, 60, 55, 99,100, 88, 87, 68, 26, 82]print(max(scores)) -----------&gt;100print(min(scores)) -----------&gt;26 =========================================================================== =========================================================================== =========================================================================== 12345678910115.相关的方法①列表.sort() --------&gt;将列表从小到大排序，改变原列表。不返回值注意：列表中的元素类型要一致，并且要支持比较运算符！！！！ 列表.sort(reverse = True) --------&gt;将列表从大到小排序，改变原列表。不返回值 注意：列表中的元素类型要一致，并且要支持比较运算符！！！！②列表.reverse() --------&gt; 将当前列表进行翻转，改变原列表。不返回值注意：列表中的元素类型要一致，并且要支持比较运算符！！！！③sorted(序列) --------&gt; 将序列中的元素从小到大排序，不改变原列表。返回一个新的序列对象③sorted(序列,reverse=True) --------&gt; 将序列中的元素从大到小排序，不改变原列表。返回一个新的序列对象 123456④列表.count(元素) --------&gt; 统计元素在列表中的个数。⑤列表.index(元素) --------&gt; 显示元素在列表中对应的下标，找出第一个元素，元素不在会报错⑥列表.extend(序列) --------&gt; 将序列中的所有元素添加到列表里面。⑦new = 列表.copy() --------&gt; 列表拷贝，类似切片&apos;列表[:]&apos;，产生新的列表。这是个拷贝浅拷贝。⑧列表.clear() --------&gt; 清空列表内的所有元素，改变原列表。","link":"/2019/10/26/%E5%88%97%E8%A1%A8(list)/"},{"title":"变量和运算符","text":"Python中的变量和运算符 ###变量 1.什么是变量？变量是用来申请空间存储数据的 2.变量的声明（使用变量就是使用变量中的值）①语法：变量名 = 值②说明：变量名 – 程序员自己命名 12345要求：是标识符，但不能是关键字规范： ①见名知义(看见变量名就大概知道变量中存储的数据) ②所有字母都要小写，如果有多个单词，单词之间用下划线隔开 ③不能使用系统提供的函数名、类名、模块名来给变量命名 = –赋值符号，将右边的值赋给左边的变量值 –任何有结果的表达式都可以作为值；例如类型的数据、已经声明过的变量、运算表达式、函数调用 1234567def mul(x, y): return x*ya = 10b = a c = 10 + 20d = mul(5, 6)print(a, b, c, d) ③同时声明多个变量 1234①变量名1 = 变量名2 = ... = 值age1 = age2 = age3 = 2 同时声明多个变量名赋相同的值②变量名1，变量名2，... = 值1，值2，...x, y, z = 1, 2, 3 同时声明多个变量名赋不同的值，注意变量名个数与值个数相等。 4.使用变量：使用变量的时候，就是使用变量中存储的值 1234x, y = 100, 200print(x + y)new_x = x * 2print(new_x) 5.修改变量的值（重新赋值）python中一个声明过的变量中的值可以修改。 1234x = 100print(x)x = 1000print(x) 6.python中声明变量的原理 1234567声明变量和重新赋值的时候，是先在内存中开辟空间存储数据，空间大小由数据本身决定；然后将数据对应的内存空间的地址给变量。======================================================================================变量三要素 ： 值（和变量关联的数据），地址（变量关联数据对应的地址），类型（关联数据的类型）①id函数：id(变量/数据) ---获取变量或者数据的地址②type函数：type(变量/数据) ---获取变量或者数据的类型(int(整型) float(浮点型) str(字符型) bool(布尔型)) —————————————————————————————–—————————————————————————————–###运算符 1.python支持的运算符：数学运算符、比较运算符、逻辑运算符、赋值运算符、位运算符 2.数学运算符：+(加)、-(减)、(乘)、/(除)、%(取余)、//(取整数)、*(幂运算) 1234567891011121314151617①+(加)、-(减)、*(乘)、/(除)和数学中的+(加)、-(减)、*(乘)、/(除)功能一样。print(5+2, 5-2, 5*2, 5/2) 输出结果：7 3 10 2.5======================================================================================②%(取余)：数字1 % 数字2 --求数字1除数字2的余数应用1：判断一个数是否能够被另外一个数整除（判断奇偶）应用2：取出一个整数的个位(num%10则取出个位)print(369 % 10) 输出结果：9======================================================================================③//(取整数)：数字1 // 数字2 --求数字1除数字2商的整数部分print(5 // 2) 输出结果：2print(5.0 // 2) 输出结果：2.0print(5 // 2.0) 输出结果：2.0应用：取一个指定长度的整数的最高位(295 // 100 则取出最高位2)======================================================================================④**(幂运算)：数字1**数字2 ---求数字1的数字2次方print(2 ** 3) 输出结果：8应用：可以用做开方运算 100**(1/2)= 10.0 3.比较运算符：&lt;(小于)、&gt;(大于)、&lt;=(小于等于)、&gt;=(大于等于)、==(等于) 、!=(不等于) *所有比较运算符返回值为True或者False* 123①&lt;(小于)、&gt;(大于)、&lt;=(小于等于)、&gt;=(大于等于)和数学的一致②==(等于) 相等返回True③!=(不等于) 不相等返回True 123456789101112补充：is 比较两个数的地址======================================================================================num1 = 100num2 = 100print(num1 is num2)此处返回True,因为数字和字符串在Python中有备份，会在赋值之前查看是否有备份，如果有就会把地址给变量。list1 = [1, 2]list2 = [1, 2]print(list1 == list2) --------Trueprint(list1 is list2) --------False此处[1,2]为列表非特定类型,没有备份所以两个[1,2]的地址不一致。 4.逻辑运算符：and(逻辑与运算)、 or(逻辑或运算)、 not(逻辑非运算)逻辑运算符的运算对象和运算结果都是布尔值 123456789101112131415161718①and(逻辑与运算)----相当于生活中的并且a.两个都为True，结果才是True，有一个False，则为Falseb.希望同时满足多个条件时使用======================================================================================②or(逻辑或运算)-----相当于生活中的或者a.一个都为True，结果是True，全部False，则才是Falseb.希望满足一个条件即可时使用======================================================================================③not(逻辑非运算)----取反not 条件语句a.运算规则：对指定条件进行否定：True变False，False变True。======================================================================================year = 2020print(&apos;是否是闰年&apos;, (year % 4 == 0) and (year % 100 != 0) or year % 400 == 0)print(&apos;是否不是闰年&apos;, not ((year % 4 == 0) and (year % 100 != 0) or year % 400 == 0))结果：是否是闰年 True是否不是闰年 False 123补充：短路操作①and的短路操作：and前面条件False后，and之后的内容不会执行②or的短路操作：or前面条件True后，or之后的内容不会执行 12345678910111213逻辑运算符的数字运算：num1 and num2 -&gt; 第一个数为0则取0，不为0则取后面那个值num1 or num2 -&gt; 第一个数不为0则取第一个数，为0则取后面那个值======================================================================================print(7 and 8)print(0 and 2)print(7 or 8)print(0 or 2)结果：8072 5.赋值运算符：=、+=、-=、=、/=、%=、*= 1赋值运算符的左边必须是变量，其中 = 的左边变量可以没有声明，+=、-=、*=、/=、%=、**=的变量必须之前就有声明 1注意：如果=的右边为一个变量，那么就是将右边变量的地址给左边的变量 1234567a = 11 -&gt;将11作为值赋给aa += 11 -&gt; a = a + 11a -= 11 -&gt; a = a - 11a *= 11 -&gt; a = a * 11a /= 11 -&gt; a = a / 11a %= 11 -&gt; a = a % 11a **= 11 -&gt; a = a ** 11 12运算符的优先级：数学运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符数学运算符优先级：** &gt; (/ = * = % = //) &gt; (+ = -) =========================================================================== 6.位运算符：&amp;(按位与运算), |(按位或运算), ^(按位异或), ~(按位取反), &gt;&gt;(右移), &lt;&lt;(左移) 12所有位运算都是针对数据在计算机存储位置的每一位进行操作所有位运算相比其他的运算符的特点：运行速度快(高效),内存消耗小 &amp;(按位与运算) (注意为补码) 12345数字1 &amp; 数字2 -&gt; 两个数字的补码同一位置都为1，则为1，不然则为01 &amp; 0 - 01 &amp; 1 - 10 &amp; 0 - 00 &amp; 1 - 0 |(按位或运算) (注意为补码) 12345数字1 &amp; 数字2 -&gt; 两个数字的补码同一位置都为0，则为0，不然则为11 | 0 - 11 | 1 - 10 | 0 - 00 | 1 - 1 ^(按位异或) (注意为补码) 12345数字1 ^ 数字2 -&gt; 两个数字的补码同一位置不同，则为1，不然则为0(不相等就为1，相等就为0)1 ^ 0 - 11 ^ 1 - 00 ^ 0 - 00 ^ 1 - 1 ~(按位取反) (注意为补码) 1~数字1 -&gt; 数字的补码各位置的0变1,1变0&gt;&gt; (右移) (注意为补码) (最高位补0或者1取决于该数是正还是负) 1数字 &gt;&gt; N -&gt; 数字的补码整体向右移N位；规律：结果就是 数字//(2**N) &lt;&lt;(左移) (注意为补码) (最低位补0) 1数字 &lt;&lt; N -&gt; 数字的补码整体向左移N位；规律：结果就是 数字*(2**N) 左移1 = 乘以2**1=========================================================================== 123456应用①判断一个数是奇数还是偶数：判断这个数的补码最后一位是0还是1,0就是偶数，1就是奇数3 &amp; 1 -&gt; 0000 0011 &amp; 0000 0001 -&gt; 0000 0001 -&gt; 1 -&gt; 奇数2 &amp; 1 -&gt; 0000 0010 &amp; 0000 0001 -&gt; 0000 0000 -&gt; 0 -&gt; 偶数===============提示，判断奇偶最好用这个，不用 %2=====================================②乘以2的次方或者除以2的次方，使用左移和右移----------(加快运算速度)","link":"/2019/10/26/%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"初识函数","text":"初始函数，函数实现了代码的封装，从面向过程编程转为面向函数编程 ###1.什么是函数函数就是对实现某一特定功能的代码的封装###2.函数的分类 123按照函数是谁来声明将函数分为系统函数和自定义函数系统函数：由系统声明，程序员直接使用的函数。如print、max、min、sum等等。自定义函数：由程序员自己声明的函数。 ###3.函数的声明(定义) 123456789101112131415161718192021①语法：def 函数名(参数列表): 函数说明文档 函数体 ②说明： def ---python声明函数的关键字,固定格式。 函数名 ---程序员自己命名的，命名要求和变量名规则差不多。见名知意--知道函数的 功能。 () ----固定格式,不能省略。 参数列表 ---- 这儿的参数叫做形参；以变量名1,变量名2,变量名3,...形式存在的。 它的作用是将函数外面的数据传递到函数里面 ： ----固定写法 函数说明文档 ----三个双&quot;引起来的文本信息，必须写在函数体的第一行 函数体 ----和def保持一个缩进的一条或多条语句。就是实现函数功能的代码段。③初学者声明函数的步骤 1.确定函数功能 2.根据功能确定函数名 3.确定函数的参数；看实现函数的功能需不需要额外的数据，需要几个就给多少个参数 4.实现函数的功能，写函数体 5.写函数说明文档 123456789101112def print_chinese(str): &quot;&quot;&quot; 功能说明：打印指定字符串中的中文字符 :param str:指定字符串 :return: &quot;&quot;&quot; for x in str: if 0x4e00 &lt;= ord(x) &lt;= 0x9fa5: print(x, end=&apos;&apos;)print_chinese(&apos;ahd125你52好rsW啊&apos;) 123456789101112def sum1(num1, num2): &quot;&quot;&quot; 功能说明：求两个数的和 :param num1: 参数说明-first number :param num2: 参数说明-second number :return: &quot;&quot;&quot; return num1 + num2sum1 = sum1(1, 2)print(sum1) ###4.函数的调用 12345678①语法函数名(实参列表)②说明函数名 ----之前已经声明过的函数的函数名() ----固定写法实参列表 ----这儿的参数叫做实参；以值1,值2,值3,...形式存在的。 它的作用是给形参赋值的(传参) ####函数的调用过程 1①回到函数声明的位置 1②用实参给形参赋值(传参);保证每个参数都有值。 1③执行函数体 1④确定函数的返回值 1⑤回到函数调用的位置，接着往后执行。 ###5.函数的参数 ####参数分类 12345①位置参数和关键字参数-----实参分类a.位置参数：让实参和形参位置一一对应，来给不同的形参赋值。b.关键字参数：以&apos;参数名1 = 值1，参数名2 = 值2...&apos;的形式来传参。注意：如果位置参数和关键字参数混用，必须是位置参数在前！ 12345②参数默认值 -----形参声明函数的时候，可以给形参赋默认值，已经有默认值的参数，在调用时就可以不用传参。如果希望跳过前面某个或某几个参数，直接给后面的参数赋值，则使用关键字参数赋值。注意：没有默认值的参数必须放在有默认值的参数的前面！ 123③参数类型说明a.给参数设置默认值，默认值的类型就是参数的类型。b.在形参后加 ----:类型名 1234④不定长参数----不确定有多少个参数时，使用不定长参数。a.在参数名前加*--那么这个参数就会变成一个元组去接受多个数据，调用的时候不能使用关键字参数传参。b.在参数名前加**--那么这个参数就会变成一个字典去接受多个数据，调用的时候必须使用关键字参数传参。 1234567891011def sum1(*num1): &quot;&quot;&quot; 功能说明：求两个数的和 :param num1: 参数说明-first number :param num2: 参数说明-second number :return: &quot;&quot;&quot; print(sum(num1))sum1() # 0sum1(1, 2) # 3 1234567891011def sum1(**num1): &quot;&quot;&quot; 功能说明：求两个数的和 :param num1: 参数说明-first number :param num2: 参数说明-second number :return: &quot;&quot;&quot; print(sum(num1))sum1() # 0sum1(x = 1,y = 2) # 3 ‘","link":"/2019/10/26/%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/"},{"title":"字典（承接上一天）和集合","text":"Python中的字典 ####1.——————运算符字典不支持 +，，&gt;, &lt;, &gt;=, &lt;= ；只支持 ==，!=####2.——————in 和 not in键 in / not in 字典 —— 判断字典中是否存在/不存在指定的键####3.——————相关函数len() —— 求键值对的个数dict(数据) —— 将其他序列转换成字典（数据必须是序列，序列中的元素必须是小序列，​ 每个小序列有且只有两个元素，且小序列第一个元素不可变）字典不能转换成数字，可以转换成布尔；*字典转换成列表时，是将字典的key作为元素** 123#——列表转字典seq = [(1, 3), ('la', 3)]print(dict(seq)) # {1: 3, 'la': 3} 1234# ——转列表seq1 = {'ha': 12, 'lala': 23}seq2 = list(seq1)print(seq2) # ['ha', 'lala'] ####4.————————相关方法1）字典.clear() —— 清空字典 123seq1 = {'ha': 12, 'lala': 23}seq1.clear()print(seq1) 2)字典.copy() —— 拷贝产生一个薪字典（浅拷贝） 123seq1 = {'ha': 12, 'lala': 23}seq3 = seq1.copy()print(seq3) 3)dict.fromkeys(序列,指定值) —— 创建一个字典，将序列中的元素作为key，key对应的值都是指定的值 12dict2 = dict.fromkeys(('lala', 'haha', 'baba'), 13)print(dict2) # {'lala': 13, 'haha': 13, 'baba': 13} 4)字典.items() —— 将字典中每个键值对转换成对应的元组，作为一个序列的元素(获取字典中所 有的key和value，返回的是一个列表中嵌套的小元组[(key1,value1),(key2,value2),…]) 123seq1 = {'ha': 12, 'lala': 23}seq1.items()print(seq1.items()) # dict_items([('ha', 12), ('lala', 23)]) 5)字典.values() —— 获取字典中所有的值，返回一个列表 123seq1 = {'ha': 12, 'lala': 23}seq1.values()print(seq1.values()) # dict_values([12, 23]) 6) 字典.keys() —— 获取字典中所有的key，返回一个列表 123seq1 = {'ha': 12, 'lala': 23}seq1.keys()print(seq1.keys()) # dict_keys(['ha', 'lala']) 7)字典.setdefault(key, 值) —— 当key不存在时添加键值对（无法修改） 12345# =================================================================seq1 = {'ha': 12, 'lala': 23}seq1.setdefault('zizi', 14)print(seq1) # {'ha': 12, 'lala': 23, 'zizi': 14}# ================================================================= 8)字典1.update(字典2) —— 将字典2的键值对添加到字典1 1234seq1 = {'ha': 12, 'lala': 23}seq2 = {'zizi': 14}seq1.update(seq2)print(seq1) # {'ha': 12, 'lala': 23, 'zizi': 14} ##===================集合================= ####1.——————————什么是集合（set）1）集合集合是容器型数据类型；将{}作为容器标志，多个元素用逗号隔开；{元素1，元素2，…..}集合是不可变，无序的2）元素集合中的元素必须是不可变的数据，而且唯一（自带去重的功能） 1set1 = {13, 14, 'baba', (13, 14)} 空集合的表示({}表示的空字典) 1set_none = set() ——————集合应用—————— 去重：集合自带去重功能 123list1 = [12, 25, 32, 12, 14, 56]list2 = list(set(list1))print(list2) ####2.————————————集合的增、删、改、查1）查 —— 获取集合元素（只有遍历集合一种方法） 123for 变量 in 集合： pass补充：遍历字典和集合时，其实是遍历由字典和集合转换后的列表 123names = {'aa', 'bb', 'cc', 'dd'}for name in names: print(name) 2）增a. 集合.add(元素) —— 在集合中添加一个元素b. 集合.update(序列) —— 将序列中的元素添加到集合 12345names = {'aa', 'bb', 'cc', 'dd'}names.add('ha')names.update((1, 2, 13))names.update('laji')print(names) 3)删集合.remove（元素）—— 删除集合指定元素，元素不存在 会报错集合.discard（元素）—— 删除集合指定元素，元素不存在 不会报错 12345names = {'aa', 'bb', 'cc', 'dd'}names.remove('bb')print(names)names.discard('aa')print(names) 4)集合不支持改的操作 ####3.————————————集合相关操作​ 1）运算符：只支持判断 == ，!=​ 2）in / not in​ 3）len()、max()、min()、sum()、sorted()、set() ####4.————————数学集合运算（重点），python支持数学的集合运算——————- 1集合符号：| (并集) ，&amp; （交集），-（差集） ^补集 123456789101112131415161718192021set3 = {1, 5, 3, 4, 6, 7}set4 = {6, 7, 9, 12}# ===========1)集合1|集合2 —— 将两个集合合并set5 = set3|set4print(set5) # {1, 3, 4, 5, 6, 7, 9, 12}# ===========2)集合1 &amp; 集合2 —— 获取两个集合的公共部分set6 = set3 &amp; set4print(set6) # {6, 7}# ===========3)集合1 - 集合2 —— 获取集合1中除了集合2与集合1的公共部分剩下的部分set7 = set3 - set4print(set7) # {1, 3, 4, 5}# ===========4)集合1^集合2 —— 获取集合1和集合2公共部分以外的部分set8 = set3 ^ set4print(set8) # {1, 3, 4, 5, 9, 12}# ===========5)集合1 &gt; 集合2 —— 判断集合1是否包含集合2（集合2是否是集合1的子集）print(set3 &gt; set4) # False 总结：需要存储多个数据时一般选择用列表或字典；如果存储多个数据不需要区分，就使用列表。​ 如果存储多个数据需要区分，就使用字典；如果涉及去重或业务逻辑中涉及数学集合运算​ 就用集合；原则上不能被修改的数据用元组 ##==============字符串和字符============== ####1.——————什么是字符串（str）字符串是容器型数据类型（序列），将’ ‘ 或 “ “作为容器标志，多个字符（元素）直接包含在引号中字符串是不可变（不支持增、删、改），且有序的 1str1 = 'halabashabi' ####2.————字符串中的元素（字符） 1）普通字符：2）特殊字符a.转义字符：在指定符号或字母前加 \\ 来表示特殊功能或者特殊意义的字符​ ' —— 表示一个单引号​ &quot; —— 表示一个双引号​ \\n —— 换行符​ \\t —— 制表符(缩进)​ \\\\ —— 表示一个\\（普通的反斜杠）注意：一个转义字符的长度是1 12345678str2 = '123\\'a\\\"16'print(str2)str3 = '床前明月光，\\n疑似地上霜'print(str3)str4 = '\\t床前明月光，\\n\\t疑似地上霜'print(str4)str5 = '123\\\\1314'print(str5) b.编码字符： \\u加4位的十六进制数表示一个字符；数字对应值是字符对应的编码值字符编码:计算机在存储数据时只能存储数字。计算机存储文字（字符）时实质存的是文字对​ 应的数字，每个数字都会对应一个固定的数字，这个数字就是字符的编码编码表：每个字符和数字的一一对应关系；​ 常见编码表：ASCII表、Unicode表（Unicode表中文范围：4E00-9FA5）（Unicode表是 对ASCII表的扩展） ============================== chr(编码值) —— 获取编码值对应的字符ord(字符) —— 获取字符对应的编码值 123str6 = '一\\u9AF5'print(str6)print(chr(1314), ord('罗'), ord('维'), ord('君')) # Ԣ 32599 32500 21531","link":"/2019/10/26/%E5%AD%97%E5%85%B8%EF%BC%88%E6%89%BF%E6%8E%A5%E4%B8%8A%E4%B8%80%E5%A4%A9%EF%BC%89%E5%92%8C%E9%9B%86%E5%90%88/"},{"title":"多线程","text":"一个正在运行的程序就是一个进程，一个进程最少有一个线程，称为主线程，一个线程同时只能处理一个任务，当想同时多任务进行时，需要用到多线程方法 进程：系统中正在运行的程序；每个进程都是独立的线程：一个进程执行任务必须至少有一条线程一个进程（程序）的所有任务都在线程中执行一个线程中任务的执行是串行的，同一时间内，一个线程只能执行一个任务 多线程：一个进程有多条线程，每条线程可以并行，同一时间执行不同的任务多线程原理：（利用CPU空闲时间去快速调度）同一时间，CPU只能处理一条线程，只有一条线程在工作（执行）多线程并发（同时）执行，其实是CPU快速的在多条线程间“调度”CPU调度线程的速度足够快，就造成了多线程并发执行的假象 1默认情况下一个程序都有一个线程，这个线程叫做主线程；主线程以外的线程叫子线程 1threading模块提供了python中相关的多线程方法和类；继承Thread类的对象就是线程对象 ###设置多线程第一种： ####1）导入threading模块 1import threading ####2) 声明一个实现线程功能的函数 12def 函数名(参数): 实现函数功能的代码 ####3）创建线程对象 threading.Thread(target,args)​ 必须用关键字传参​ target —— 函数，需要在子线程调用的函数​ args —— 元组，接收子线程中被调用函数的实参（调用函数无参时，args不用赋值） 1线程对象 = threading.Thread(target=实现线程功能的函数, args=(函数的参数)) ####4）启动线程 线程对象.start（） ###设置多线程第二种： ####1）导入threading模块 1import threading ####2）通过创建Thread的子类对象来创建线程 12345678class 类名(Thread): def __init__(self, 参数1，参数2...): super().__init__() # 获取父类对象属性 self.参数1 = 参数1 ...... def run(self) -&gt; None: # -&gt; None 起提示返回值的作用 实现线程功能的代码 ####3）创建子类对象 子类对象（线程对象） = 类名(参数) ####4)启动线程 子类对象.start()","link":"/2019/10/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"字符串的操作","text":"Python中的字符串 ####字符串的操作 1.查(获取字符串中的字符) 123补充 r语法str = r&apos;\\n\\t\\u4e00sdsada&apos; --------&gt; \\n\\t\\u4e00sdsada在字符串之前加一个r，就会让字符串内的转义字符失去功能(一般在正则表达式中使用) 1①获取单个字符: 字符串[下标] 1234str1 = &apos;abcdefghi&apos;prit(str1[2]) ----&gt; cstr2 = &apos;acd\\n123\\u4e00lk&apos;print(str2[7]) ----&gt; \\u4e00 1②字符串切片: 字符串[开始下标：结束下标：步长] ---&gt;str[start_index:end_index:step_size] 123456str1 = &apos;hello world!&apos;print(str1[1:]) --------&gt;ello world!print(str1[:1]) --------&gt;hprint(str1[::2]) --------&gt;hlowrdprint(str1[:2]) --------&gt;heprint(str1[::-1]) --------&gt;!dlrow olleh 1字符串的相关操作 123456789101112131415161718192021222324①算术运算符： +，*字符串1+字符串2 ----&gt;将字符串1和字符串2拼接在一起形成一个新的字符串字符串*N 或者 N*字符串 -----&gt;将字符串重复N次形成一个新的字符串②比较运算符：&gt;,&lt;,&gt;=,&lt;=,==,!= (比较相同为为止的字符的大小，比较的是编码值大小)print(&apos;abceef&apos; &gt; &apos;bc&apos;) ---------&gt; False应用：判断字符是否是大写字母：&apos;A&apos;&lt;= char &lt;=&apos;Z&apos;判断字符是否是小写字母：&apos;a&apos;&lt;= char &lt;=&apos;z&apos;判断字符是否是字母：(&apos;A&apos;&lt;= char &lt;=&apos;Z&apos;) or (&apos;a&apos;&lt;= char &lt;=&apos;z&apos;) 判断字符是否是中文字符：&apos;\\u4e00&apos; &lt;= char &lt;= &apos;\\u9f45&apos;判断字符是否是数字：48 &lt;= ord() &lt;= 57③in 和 not in 字符串1 in 字符串2 -判断字符串2是否包含字符串1(判断字符串1是否是字符串2的字串)④相关函数 len、max、min、sorted、strstr(数据) -将指定的数据转换成指定的字符串；(所有类型的数据都可以转换为字符串)字符串转整型 ---字符串去掉引号后本生就是整型，就可以转，不然会报错int(数据)字符串转浮点型 --字符串去掉引号后本生就是数，就可以转，不然会报错float(数据) 12345678910格式字符串什么是格式字符串 ---&gt;字符串中使用格式占位符来代替字符串中变化的部分。语法：带有格式占位符的字符串 % (值1，值2，值3...)% ---固定写法() ----固定写法，当格式占位符只有一个的时候，()可以省略值 ----值的数量和格式占位符一一对应，数据类型也要一一对应。 123456格式占位符：%s----------&gt;变化部分对应的值应该是字符串%d----------&gt;变化部分对应的值应该是整型%f----------&gt;变化部分对应的值应该是浮点型，默认小数后6位%.Nf----------&gt;变化部分对应的值应该是浮点型，精确到小数后的位数%c----------&gt;变化部分对应的值应该是字符 12345格式字符串带有{}的格式字符串.format(值1,值2,值3...)message= &apos;{1}，{0}，{2}，{1}&apos;.format(&apos;one&apos;,&apos;two&apos;,&apos;three&apos;)print(message) --------&gt;two,one,three,two 12345数字格式message = &apos;{}&apos;.format(3.1415926)print(message)-------------&gt;3.1415926message = &apos;{:2.f}&apos;.format(3.1415926)print(message)-------------&gt;3.14-----&gt;结果四舍五入 ####字符串的相关方法 123456789101112字符串对齐：①字符串.center(长度,字符)--------&gt;产生指定长度的字符串，原字符串居中，其他位置用指定的字符填充②字符串.rjust(长度,字符)--------&gt;产生指定长度的字符串，原字符串居右，其他位置用指定的字符填充③字符串.ljust(长度,字符)--------&gt;产生指定长度的字符串，原字符串居左，其他位置用指定的字符填充④字符串.zfill(长度)--------&gt;产生指定长度的字符串，原字符串居右，其他位置用0填充 12345查找：①字符串1.find(字符串2) (没有返回-1，表示没有这个字符串)----&gt;查找字符串2第一次出现在字符串1中的位置，返回首字符的下标,没有不会报错。②字符串1.index(字符串2)----&gt;查找字符串2第一次出现在字符串1中的位置，返回首字符的下标,没有会报错。 12345678join：字符串1.join(序列)-----&gt;将序列中的元素用字符串1连接在一起产生一个新的字符串序列中的元素必须是字符串names = [&apos;hello&apos;,&apos;world&apos;,&apos;!&apos;]name_new = &apos; &apos;.join(names)print(name_new)-----&gt;hello world ! 1234567891011121314151617①字符串.lower()-------&gt;将字符串的大写字母转换成小写字母，返回一个新的字符串对象②字符串.upper()-------&gt;将字符串的小写字母转换成大写字母，返回一个新的字符串对象③字符串.rstrip(字符)-------&gt;将字符串右边的指定字符删除，默认删除空格，返回一个新的字符串对象④字符串.strip(字符)-------&gt;将字符串两边的指定字符删除，默认删除空格，返回一个新的字符串对象⑤字符串.lstrip(字符)-------&gt;将字符串左边的指定字符删除，默认删除空格，返回一个新的字符串对象⑥字符串.capitalize()-------&gt;将字符串第一个字母变为大写，其余字母小写，返回一个新的字符串对象 如果字符串第一位不是字母，则只是将之后的字母全部小写，返回一个新 的字符串对象⑦字符串.swapcase()-------&gt;将字符串中的字母大小写互动，返回一个新的字符串对象，返回一个新的 字符串对象 12345678910替换：①字符串1.replace(old,new)-------&gt;将字符串1中所有的old替换成new，产生一个新的字符串。②str.maketrans(字符串1，字符串2) --&gt;创建字符串1和字符串2一一对应的映射表，字符串1是需要被替换的字符，字符串2是目的字符，形成映射表 返回一个映射表对象字符串.translate(映射表)---&gt;按照映射表对字符串中的字符进行替换，返回一个新的字符串对象 12345字符串切割：字符串1.split(字符串2)---&gt;将字符串1中的字符串2作为切点，切割字符串1，返回一个列表，元素是分隔出的元素list = &apos;how are you? i am fine, thank you!&apos;.split()print(list)----&gt;[&apos;how&apos;, &apos;are&apos;, &apos;you?&apos;, &apos;i&apos;, &apos;am&apos;, &apos;fine,&apos;, &apos;thank&apos;, &apos;you!&apos;]","link":"/2019/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"属性的getter和setter、私有化、继承、运算符重载","text":"类中的getter和setter 属性的getter和setter1.getter和setter的作用12如果需要在获取属性值之前做别的事情，就给这个属性添加getter如果需要在给属性赋值之前做别的事情，就给这个属性添加setter 2.怎么添加getter和setter1234567891011121314151617# 1)添加getter&quot;&quot;&quot;①属性前加一个下划线‘_’②声明一个函数，声明前加@property。函数名就是不带_的属性名 除了self之外不需要其他参数，必须要有返回值就是处理后的值③在类的外部使用这个属性时，去掉‘_’去使用&quot;&quot;&quot;# 2)添加setter&quot;&quot;&quot;注意：如果要添加setter，必须先添加getter！①保证属性名前有_②声明一个函数，声明前加@getter名.setter 函数名是不带&apos;_&apos;的属性名；除了self以外需要一个参数，不 需要返回值(需要完成给属性赋值的功能)③在类的外部给这个属性赋值的时候去掉&apos;_&apos;&quot;&quot;&quot; 12345678910111213141516171819202122232425262728293031323334class Person: def __init__(self, name, age): self.name = name self._age = age @property def age(self): if self._age &lt; 18: return &apos;未成年&apos; else: return &apos;成年&apos; @age.setter def age(self, value): if isinstance(value, int): if 0 &lt; value &lt; 100: self._age = value else: raise ValueError # 弹出错误 else: raise ValueErrordef main(): p1 = Person(&apos;wang&apos;, 17) print(p1.age) p1.age = &apos;a&apos; # ValueError p1.age = 20 print(p1.age)if __name__ == &apos;__main__&apos;: main()else: pass 私有化1.访问权限123456&quot;&quot;&quot;类中的属性和方法根据访问权限的不同分为三种：公开的、保护的、私有的public：类的外部、类的外部都能使用，可以被继承protect：类的内部可以使用，外部不准使用，可以被继承private：类的内部使用，不能被继承&quot;&quot;&quot; 2.Python中属性和方法的访问权限1234&quot;&quot;&quot;python中所有属性和方法本质都只有公开的这一种访问权限私有化是假的私有化，只是为了告诉开发者这个属性或方法是私有的，不要在外部使用&quot;&quot;&quot; 3.私有化的方式12345&quot;&quot;&quot;在需要私有化的属性名或方法前加&apos;__&apos;,加两个下划线私有化的原理：设置带有两个下划线开头的属性名和方法时，系统会自动在其前面加&apos;_类名&apos;，导致访问不了。&quot;&quot;&quot; 1234567891011121314151617181920212223class Person: __num = 100 # 此处将name设为私有化 def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def eat(self, food): print(&apos;%s在吃%s&apos; % (self.name, food))def main(): p1 = Person(&apos;小明&apos;, 18, &apos;man&apos;) p1.eat(&apos;包子&apos;) # print(p1.__name) # AttributeError:if __name__ == &apos;__main__&apos;: main()else: pass 继承1.什么是继承12345&quot;&quot;&quot;让一个类直接拥有另一个类的属性和方法，这个过程就叫做继承父类：被继承的类,又叫超类子类：去继承别的类的类(继承)&quot;&quot;&quot; 2.怎么继承123456789&quot;&quot;&quot;class 类名(父类1,父类2...): 类的说明文档 类的内容 说明：1.() -可以省略，相当于&apos;(object)&apos;，object是python中所有类直接或间接父类，也叫基类2.父类 - 有括号的时候，括号中可以写一个或者多个父类&quot;&quot;&quot; 3.能继承什么东西123&quot;&quot;&quot;所有的方法和属性，除了slots魔法&quot;&quot;&quot; 4.如果需要添加子类的方法和属性a.添加子类的类的字段和方法123&quot;&quot;&quot;在子类中直接声明方法和字段&quot;&quot;&quot; b.添加对象属性1234&quot;&quot;&quot;需要在子类的init方法中通过super()去调用父类的init方法，它的作用是保留父类的对象属性&quot;&quot;&quot; c.补充函数的调用过程1234567&quot;&quot;&quot;当通过类或对象去调用函数的时候，是先看当前类中有没有声明这个函数，如果有就调用自己的如果没有就去找父类中有没有这个函数，有就调用父类中的函数如果父类没有，就去找父类的父类中有没有以此类推...直到找到object也没有这个函数，就会报错&quot;&quot;&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person: position = &apos;人类&apos; def __init__(self, name, age, gender): self.name = name self.age = age self.gender = gender def eat(self): print(&apos;%s在吃东西&apos; % self.name) @classmethod def warning(cls): print(&apos;%s在破坏环境&apos; % Person.position)class Student(Person): position = &apos;学生&apos; def __init__(self, name, age, gender, score): super().__init__(name, age, gender) # 调用父类的对象参数 self.score = score def study(self): print(&apos;%s在学习&apos; % self.name) @classmethod def warning(cls): super().warning() print(&apos;%s也在破坏环境&apos; % cls.position) def __repr__(self): return &apos;&lt;%s&gt;&apos; % str(self.__dict__)[1:-1]def main(): stu1 = Student(&apos;wang&apos;, 18, &apos;women&apos;, 98) print(stu1) Student.warning()if __name__ == &apos;__main__&apos;: main()else: pass 多继承 Python中的类支持多继承,多继承的时候，子类只能继承第一个父类的对象属性 12345678910111213141516171819202122232425262728293031323334353637383940class Animal: num = 100 def __init__(self): self.age = 3 self.gender = &apos;公&apos; @classmethod def show_all_num(cls): print(&apos;动物的数量:%s&apos; % cls.num)class Fly: name = &apos;飞行器&apos; def __init__(self): self.height = 1000 self.time = 12 self.speed = 50 @staticmethod def fun1(): print(&apos;FLY中的静态方法&apos;)class Bird(Animal, Fly): passdef main(): b1 = Bird() # print(b1.height) #attrbute error print(b1.age) Bird.fun1()if __name__ == &apos;__main__&apos;: main()else: pass 运算符重载123456789101112&quot;&quot;&quot;java/c++/c#等语言中的重载指的是函数名相同，但是参数不一样的多个函数,python不支持函数重载void fun1(){}void fun1(int a){}当调用时fun1中没参数时，调用函数1，有参数a，调用函数2&quot;&quot;&quot; 1.运算符重载123456&quot;&quot;&quot;Python中在使用不同运算符对数据进行运算的时候，本质就是在调用方法当不同类型的数据在使用相同的运算符的时候，调用的方法名相同，但是方法不同看某种类型会否支持某种运算符，就看这个类型对应的类中是否实现了对应的方法&quot;&quot;&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041class Person: def __init__(self, name, age, gender=&apos;man&apos;): self.name = name self.age = age self.gender = gender &quot;&quot;&quot; self - 运算符前面那个数据 other - 运算符后面的那个数据 返回值 - 运算结果 &quot;&quot;&quot; def __repr__(self): return &apos;&lt;%s&gt;&apos; % str(self.__dict__)[1:-1] def __add__(self, other): return self.age + other.age def __mul__(self, other): list1 = [] for _ in range(other): list1.append(self.__dict__) return list1 def __lt__(self, other): # 重载小于符号 return self.age &lt; other.agedef main(): p1 = Person(&apos;小花&apos;, 18, &apos;woman&apos;) p2 = Person(&apos;小mo&apos;, 12, &apos;woman&apos;) p3 = Person(&apos;jack&apos;, 14, &apos;woman&apos;) print(p1) print(p1+p2) print(p1*2) list1 = [p1, p2, p3] list1.sort() print(list1)if __name__ == &apos;__main__&apos;: main()else: pass","link":"/2019/10/26/%E5%B1%9E%E6%80%A7%E7%9A%84getter%E5%92%8Csetter%E3%80%81%E7%A7%81%E6%9C%89%E5%8C%96%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"Linux基础","text":"命令名称 [命名参数][命令对象] 一、日常操作 1.cd指令 - 进入指定文件夹 cd 目录 - 进入指定目录(也可以是文件夹对应的路径) ​ ~相对路径 — 绝对路径 cd .. - 返回上层目录 cd ~ - 回到根目录 cd / - 进入系统根目录 \\2. ls指令 - 查看当前目录中的内容 ls ls -l/-lh - 查看详情 ls -a - 隐藏文件也一起显示 ls -R - 递归显示所有内容 ls -S/-t - 按大小/时间排序 注意: 多个功能不冲突的参数可以同时使用，中间用空格隔开, 例如 - (ls -lh -S) 3.pwd指令 - 显示当前完整目录 pwd 4.文件操作指令 touch 文件名 - 新建文件 cat 文件名 - 查看文件内容 vim/vi 文件名 -打开文件 rm 文件名 - 删除文件(询问是否删除) rm -f 文件名 - 强制删除文件(不询问) rm - r 目录 - 删除文件夹 rm -rf 目录、 rm -r -f 目录 - 删除文件夹(不询问) cp 文件名1 文件名2 - 将文件1中的内容拷贝到文件2中 cp 文件 目录 - 将指定文件拷贝到指定目录中 cp -r 文件名/目录名 目录2 - 将文件/目录拷贝到目录2中 mv 文件名1 文件名2 - 将文件1中的内容移动到文件2中 ,并且删除文件1（文件重命名） mv 文件1路径 文件2路径 mv 文件名1 新文件名 - 重命名 mv 文件名1 文件目录 - 将文件1移动到指定目录中 注意: mv指令不能加-r来操作目录 (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) mkdir 目录名 - 新建文件夹 mkdir -p a/b/c - 按层级创建a,b,c三个文件夹 mkdir -p a/{b,c}/{d,e,f} -同一层级常见多个 rmdir 目录名 - 删除指定空目录 7.history - 显示历史指令记录 bashrc 配置显示时间：export HISTTIMEFORMAT=”[%y‐%m‐%d_%T] “ 修改bashrc 后使其生效: source ~/.bashrc 或 . .bashrc 6.链接 ln -s 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个软链接(可以看成是快捷键)(源路径是绝对路径) (掌握！) ln 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个硬链接(看成一个数据的多个引用)（了解） 注意: 源文件不存在的时候，软件无效，硬链接变成普通文件 8.快捷键 ctr + f - 前进一个字符 ctr + b - 后退一个字符 ctr + a - 回到行首 ctr + e - 回到行尾 ctr + w - 向左删除一个单词 ctr + u - 向左删除全部 ctr + k - 向右删除全部 ctr + y - 粘贴上次删除的内容 ctr + l - 清屏 二、进程相关指令(用得较少) 1.ps指令 ps - 进程状态 ps -aux 或者 ps ex - 查看进程 ps -aux|grep 进程名 - 查看指定进程 ps grep 进程ID 2.top指令 top - 动态监控进程 top -p PID1,PID2,…. - 动态监控指定进程 3.free指令 free -单位 - 以指定单位查看内存, 例如 free -m (以Mb为单位显示内存状况), -g, -k等！ 4.kill指令 kill 进程号 - 杀死指定的进程 kill -1/-9/-15 进程号 - -1(HUP)不间断重启，-9(KILL)强制杀死进程, -15(TERM)正常终止进程 pkill 进程名 - 按名字处理进程 killall 进程名 - 处理名字匹配的进程 5.uptime - 查看系统状态 三、权限管理 1.user和group : 一个系统可以有多个用户和多个分组； 一个分组中可以有多个用户，一个用户在不同的分组中(多对多) users - 查看当前用户 groups - 查看当前分组 groupadd 分组名 - 添加分组 (能在/etc/group文件中查看到新的分组, root才有的权限) useradd 用户名 - 创建新的用户(还是在home中自动创建这个用户对应的文件夹， root才有的权限) useradd ‐G 分组列表 ‐m ‐s /bin/bash 用户名 - 创建一个用户添加到指定的分组中(在home创建相应的文件夹) usermod -G 分组列表 用户名 - 修改分组(root才有的权限) passwd 用户名 - 修改密码（root才有权限） passwd - 修改当前账号密码 su 用户名 - 切换用户身份(root不需要密码，其他用户需要密码) sudo - 以管理员执行其他程序 注意： a.在ubuntu需要将用户添加到sudo分组中，才能使用sudo以管理员的身份执行程序 ​ b.在centOS中需要先执行vi 指令进入/etc/sudoers文件中在指定的位置添加内容 ​ ## Allow root to run any commands anywhere ​ root ALL=(ALL) ALL ​ xiaoming ALL=(ALL) ALL (自己添加的，xiaoming是用户名) 2.chmod(记住！) chmod 权限值 文件 - 修改指定文件的权限 chmod [a,u,g,o][+,-][r,w,x] 文件 - 为指定文件，给所有用户添加相应的权限 ​ (a:所有，u:自己，g:同组，o:其他； ​ +：添加， -: 取消； ​ r:读，w:写，x:执行) chown 用户名 文件 - 改变文件所有者 ![file-mode.png](/Users/yuting/Library/Application Support/typora-user-images/17C12B13-6680-4C3A-8E21-C9C9250DEAE1/file-mode.png) (权限制是三组二进制值) self group other rwx rwx rwx 111 101 001 - 自己读写可执行，同一分组的只读可执行，其他的只可执行 110 100 000 chmod 644 文件 chmod 777 文件 chmod 666 文件 三、日志管理 1.cat指令 cat 文件 - 查看文件内容 2.查看部分 head -n N 文件 - 查看前N行内容 tail -n N 文件 - 查看后N行内容 3. less 文件 ​ - 按 j 向下 ​ - 按 k 向上 ​ - 按 f 向下翻屏 ​ - 按 b 向上翻屏 ​ - 按 g 到全文开头 ​ - 按 G 到全文结尾 ​ - 按 Q 退出 more [-N] 文件 - 和less差不多，这个是尽可能多，less是尽可能少的加载 4.处理(对通过其他指令获取的结果进行处理) sort - 排序 (cat 文件 |sort) uniq - 去重 (cat 文件 |uniq) - 只会去重相邻的重复是数据，一般结合sort一起使用: |sort|uniq awk ‘{print $N}’ - 打印第N列的内容(netstat -natp|awk ‘{print $4}’) awk ‘{print $N1,$N2,$N3,…}’ history |awk ‘{print $4}’ |sort |uniq ‐c | sort ‐rnk 1 | head ‐n 3 -获取历史指令中，使用最频繁的三个指令 uniq ‐c -去重的时候统计每一行内容的重复出现的次数 sort -nk 1 - 数值大小从小到大排序 sort -nk 2 - 字符大小从小到大排序(默认) sort -rnk 1 - 数值大小从大到小排序 sort -rnk 2 - 字符大小从大到小排序(默认) 5.重定向 执行获取数据的指令 &gt; 文件 （将执行指定的结果存储到文件中 - 覆盖原文件中内容） 执行获取数据的指令 &gt;&gt; 文件 (将执行指定的结果存储到文件中 - 在原文件的最后追加) 5.统计 wc -c(字符)/-w(单词)/-l(行) 文件 6.查找 grep 查看对象 目录/文件 参数 ​ ​ 参数： ​ -i 忽略大小写: grep you bb.txt -i ​ -n 显示行标号： grep you bb.txt -n / grep you bb.txt -i -n ​ -E 通过正则表达式匹配: grep -E ‘正则表达式’ 文件 ​ 注意： Linux中，正则不支持: \\d, \\s,\\w,\\b,\\D,\\S,\\W,\\B ​ 支持：. +, *, ?, {N,M}, [], ^, $ ​ -v 忽略字段: grep you bb.txt -v (在bb.txt中找不包含you的所有行) ​ grep -E ‘[0-9]+.[0-9]+’ abb.txt -v ​ -rn 递归查找目录，并打印行号 ​ grep -r you ./ (在当前文件夹下中所有文件中去找包行’you’的行) ​ ​ // 对文件格式进行约束 ​ —include=‘.py’ 仅包含 py文件: grep -r you ./ –include=‘.txt’ ​ —exclude=‘.js’ 不包含 js 文件: grep -r you ./ –exclude=’.c’ ​ 例如： ​ grep you bb.txt ​ grep you bb.txt -i ​ grep you bb.txt -i -n ​ grep -E ‘[0-9]+’ bb.txt // 在文件夹下找满足条件的文件 find DIR -name ‘.xxx’ 找到目录下所有名字匹配的文件: find a1 -name ‘.txt’(在文件夹a1中找所有txt文件) find 路径 -size +/-文件大小 例如: find ./ +20k (在当前目录下找文件大小大于20k的文件) ​ 例：find ./ -size +20k -size -100k -name ‘*.txt’ (找当前目录下大于20k并且小于100k的所有txt文件) // 查指令 which 指令 - 精确查找当前可执行的指令 whereis 指令 - 查找所有匹配的命令 man 指令 -使用指令手册 四、网络管理 ifconfig 查看网卡状态 netstat -natp - 查看网络连接状态 netstat -natp|grep 端口号 - 查看指定端口的网络连接状态 *ping 地址 ping -i 时间 地址 ping -c 次数 地址 telnet ip地址 端口 - 查看远程主机网络连接状况（需要telnet环境） dig 地址 - 查看DNS (需要环境支持) ** wget 地址 - 下载 五、使用包管理工具(掌握) 包管理工具：yum yum search：搜索软件包，例如yum search nginx。 yum list installed：列出已经安装的软件包，例如yum list installed | grep zlib。 yum install：安装软件包，例如yum install nginx。 yum remove：删除软件包，例如yum remove nginx。 yum update：更新软件包，例如yum update可以更新所有软件包，而yum update tar只会更新tar。 yum check-update：检查有哪些可以更新的软件包。 yum info ：显示软件包的相关信息，例如yum info nginx。 源代码构建安装 wget 安装包的路径 -下载安装包 gunzip/tar 压缩包 - 解压、解归档 (设置安装路径) cd 安装包目录 执行: make &amp;&amp; make install -编译安装包程序 给可执行文件添加软连接到usr/bin目录下 -添加快捷方式 压缩/解压缩和归档/解归档 - gzip / gunzip / xz / tar 发送远程文件 - scp指令： scp 文件 root@IP地址:服务器上保存被发送文件的路径","link":"/2019/10/26/%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E6%8C%87%E4%BB%A4/"},{"title":"异常捕获","text":"Python代码出错，程序会异常，这个时候我们可进行异常捕获，让错误可控 异常捕获异常-程序执行那个过程中出现错误(报错) 1234print(&apos;============&apos;)# 如果程序出现异常，那么程序会直接结束，不再执行后面的其他语法print([1, 2][20])print(&apos;++++++++++++&apos;) 异常捕获 -让程序出现异常的时候程序不崩溃，可以接着往后执行。 什么时候需要捕获异常 - 明知道某个位置程序可能会出现异常，但没法通过程序来控制的时候就使用异常捕获。 异常捕获的语法语法一：捕获所有类型的异常12345678910111213141516171819try: 代码块1except: 代码块2 说明：try - 关键字，固定写法代码块1 - 和try保持一个缩进的一条语句或多条语句；需要捕获异常的语句。except - 关键字，固定写法代码块2 - 和except保持一个缩进的一条或多条语句；出现异常后对这个异常进行处理的代码。执行过程：先执行代码块1 ①代码块1如果出现异常，直接执行代码块2，再执行代码块2后的语句 ②代码块1如果不出现异常，直接执行代码块2后的语句。 try: age = int(input(&apos;please input your age:&apos;))except: print(&apos;input error!please input a number with class int&apos;) 1234567891011121314def num(): while True: try: age = int(input(&apos;please input your age:&apos;)) print(type(age)) return age except: print(&apos;input error!please input a number with class int&apos;) print(&apos;please input again!&apos;)your_age = num()print(type(your_age))print(your_age) #####语法二：捕获指定的异常 123456789try: 代码块1except 错误类型: 代码块2 执行过程：先执行代码块1 ①代码块1如果出现异常，并且异常类型和except后面的错误类型一致， 再执行代码块2后的语句 ②代码块1如果不出现异常，并且异常类型和except后面的错误类型不一 致，程序直接崩溃 #####语法三、四：同时捕获多种指定的异常 123456789101112131415try: 代码块1except (错误类型1,错误类型2...): 代码块2 try: 代码块1except 错误类型1: 代码块2except 错误类型2: 代码块3... finally12以上所有的语法结构的最后都可以加一个finally，加完后不会影响原结构的功能。特点：try后面的代码块不管发生什么情况，finally后的代码块会被执行 抛出异常12raise 异常类型出现指定条件后，直接终止程序，报出异常！ 模块1一个python文件就是一个模块 #####模块间的互相引用 怎么在一个模块中去使用另一个模块的内容：导入模块 1234&quot;&quot;&quot;improt 模块名 - 模块名就是py文件的文件名导入模块中的所有内容，可以在当前模块中能使用其中的所有全局变量--以 ‘模块名.变量’的 方式去使用&quot;&quot;&quot; 1234&quot;&quot;&quot;from 模块名 import 变量名1,变量名2...导入模块，可以在当前模块中能使用其中的指定全局变量--变量直接使用，不用加前缀&quot;&quot;&quot; 1234&quot;&quot;&quot;from 模块名 import *导入模块中的所有内容，可以在当前模块中能使用其中的所有全局变量--变量直接使用，不用加前缀&quot;&quot;&quot; 12345678&quot;&quot;&quot;模块重命名improt 模块名 as 新模块名 --导入指定模块，并给模块重新命名；在当前模块中应使用新的 模块名from 模块名 import 变量名 as 新变量名 --导入指定模块，并给模块重新命名；在当前模块 中应使用新的模块名&quot;&quot;&quot; ###导入模块的原理 1当我们通过import或者from import 导入模块的时候，会将该模块中的代码全部执行一遍。 12345678怎么导入模块的时候选择性的执行部分代码。代码段1if __name__ == &apos;__main__&apos;: 代码段2 在直接执行当前模块时，两个代码段都会运行，在被调用导入时，只会执行代码段1。 1原理：在创建py文件时，系统会自动声明一个__name__的变量，它的默认值就是&apos;文件名&apos;，当直接运行该文件时，__name__的值会自动变成&apos;__main__&apos;，执行结束变回文件名。 ###常用模块 math1math time1time os1os sys1sys datetime1datetime hashlib123456789101112131415161718192021222324252627hashlib是什么?hashlib是python提供用来产生摘要算法的模块。--摘要算法又叫哈希算法、离散算法。 经典算法：md5算法、sha算法 哈希算法的特点： ①该算法不可逆，不能根据摘要(密文)不能获取/推导原文。 ②使用相同算法对相同的数据加密后的摘要是一样的 ③不同长度的数据通过相同算法加密后产生的摘要的长度是一样的。 怎么生成密文/摘要：import hashlib# 1.根据算法创建对象hash1 = hashlib.md5()# 2.对数据进行加密 --指定加密数据，转换成二进制数据hash1.update(&apos;123456&apos;.encode())&quot;&quot;&quot;补充：二进制数据和字符串的相互转换 二进制数据：bytes 字符串转二进制：bytes(字符串，encoding=&apos;utf-8&apos;) / 字符串.encode() 二进制转字符串：str(二进制，encoding=&apos;utf-8&apos;) / 二进制.decode(encoding=&apos;utf-8&apos;)&quot;&quot;&quot;# 3.获取摘要 -- 哈希对象.hexdigest()pw = hash1.hexdigest()print(pw) calendar此模块的函数都是日历相关的，例如打印某月的字符月历。 星期一是默认的每周第一天，星期天是默认的最后一天。 #####calendar.calendar(year,w,l,c) 12calendar.calendar(year,w=2,l=1,c=6)返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。都有默认值 calendar.isleap(year)1234import calendarprint(calendar.isleap(2000)) # Trueprint(calendar.isleap(1900)) # False是闰年返回 True，否则为 false。 calendar.leapdays(year1,year2)1返回在Y1，Y2两年之间的闰年总数。 calendar.monthrange(year,month)123456返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。&gt;&gt;&gt; import calendar&gt;&gt;&gt; calendar.monthrange(2014, 11)(5, 30)(5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。 时间戳1时间戳--&gt;两个时间的差值，用当前时间减去1970年1月1日0时0分0秒的差值，用单位秒来表示","link":"/2019/10/26/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"},{"title":"文件操作以及json文件","text":"每次执行Python代码结束，它里面的数据都会消失，想要长久保存，就需要用到文件操作的部分来保存数据 ####1.数据存储和数据本地化-(数据持久化) 使用eval()可将字符串转成列表或字典，这个字符串必须是去掉引号都本身就是字典或列表。1.将需要持久化的数据保存到本地文件中。 2.需要使用这个数据时去文件中读取。 3.数据发生改变时，要将最新的数据更新到文件中。 123456&quot;&quot;&quot;程序中产生的数据默认都是保存在运行内存中，这些数据在程序运行结束后会自动销毁。如果希望数据在程序结束后不销毁，就必须将数据存储在硬盘上(通过文件保存)&quot;&quot;&quot;text文件、json文件、plist文件、各种数据库文件图片文件(png、jpg、jpeg)，音频文件、视频文件 ####2.怎么把数据保存在硬盘中 123&quot;&quot;&quot;基本步骤：打开文件(创建文件)-&gt;操作文件(读操作或者写操作)-&gt;关闭文件&quot;&quot;&quot; ####3.打开文件(创建文件)—以指定的方式打开指定文件并返回文件对象。 123456789101112open(file, mode=&apos;r&apos;, encoding=None)file - 字符串，指向文件的路径，可以是绝对路径也可以是相对路径mode - 字符串，读写方式；决定打开文件后能做什么，以及读写的数据类型 r -read-只读 w -write-先清空再写-只写 a -在源文件后追加内容 b -binary mode-单独表示二进制，显示的是二进制 t -表示文本信息，字符串等，显示的数据会是字符串 注意：b和t不写的时候，就默认tencoding -字符串，表示文本文件的编码方式，一般使用&apos;utf-8&apos; 注意：1.打开二进制数据不能设置encoding，即mode带有b的不能设置encoding 2.同一文件读和写都应使用同样的编码方式。 1234567f = open(&apos;./01.text&apos;, mode=&apos;rt&apos;, encoding=&apos;utf-8&apos;)while True: content = f.readline() if content: print(content, end=&apos;&apos;) else: break ####4.操作文件 12345678910①读操作 - 获取文件中的内容a. 文件对象.read()--获取指定文件对象中的内容，从文件读写位置开始到文件结束。b. 文件对象.readline()--获取指定文件对象中的内容，从文件读写位置开始到一行结束。c. 文件对象.seek(0)--设置读写位置，将文件读写位置设置到开头。②写操作 - 修改文件中的内容a. 文件对象.write(&apos;需要写的数据&apos;) --将指定数据写入文件，数据只能是结果是字符串的数 据或者是二进制数据③关闭文件 文件对象.close() --文件关闭后，不能再进行读写操作。 123f = open(&apos;./01.text&apos;, mode=&apos;at&apos;, encoding=&apos;utf-8&apos;)f.write(&apos;success&apos;)print(f) ####5.文件作用域 1234with open(file, mode=&apos;r&apos;, encoding=None) as 文件对象: 文件作用域 文件作用域 -- 只有在文件作用域范围内才能操作文件；离开作用域文件会自动关闭 123456with open(&apos;./01.text&apos;, mode=&apos;rt&apos;, encoding=&apos;utf-8&apos;) as f: content = f.read() print(content) content = f.read() ---&gt; ValueError: I/O operation on closed file. 12345678# 写一个程序，在程序中打印当前程序运行的次数with open(&apos;./01.text&apos;, mode=&apos;rt&apos;, encoding=&apos;utf-8&apos;) as f: content = f.read() print(&apos;程序运行的次数：%s&apos; % str(int(content)+1))with open(&apos;./01.text&apos;, mode=&apos;wt&apos;, encoding=&apos;utf-8&apos;) as f: f.write(str(int(content)+1)) 6.打开不存在的文件eval()相当于去掉字符串两边的引号 12如果以读的方式打开一个不存在的文件，程序化会报错。如果以写的方式打开一个不存在的文件，程序化不会报错，会自动创建这个文件再打开。 12345678910111213# 写一个程序，添加学生信息（姓名和成绩）stus = {}stus[&apos;姓名&apos;] = input(&apos;请输入姓名：&apos;)stus[&apos;成绩&apos;] = input(&apos;请输入成绩：&apos;)with open(&apos;./01.text&apos;, mode=&apos;rt&apos;, encoding=&apos;utf-8&apos;) as f: content = f.read() content = eval(content)content.append(stus)print(content)with open(&apos;./01.text&apos;, mode=&apos;wt&apos;, encoding=&apos;utf-8&apos;) as f: f.write(str(content)) ###json json数据：一种数据格式 json读的数据格式 123456789①一个json有且只有一个数据②这个数据必须是json支持的数据类型的数据③json支持的数据类型： 数字类型(包含所有的数字)，支持科学计数法。例如 1, 2.13, 3e5 字符串 -用双引号引起来的数据，只能是双引号 &quot;hello&quot;, &quot;world&quot; 布尔 -只有true和false两个值 空值 -null 数组 -相当于Python中的列表 [元素1，元素2，元素3，...] 字典 -相当于Python中的字典 {&apos;key1&apos;:value1,&apos;key2&apos;；value2，...} key是字符串 json和python的数据转换– json模块1json --&gt; python (爬虫、数据可视化、数据分析) ---json.loads() json python 数字 》》 int或者float 字符串 》》 str，可能会将双引号变成单引号 布尔 》》 ture-&gt;Ture false-&gt;False 空值 》》 null-&gt;None 数组 》》 list 字典 》》 dict 123json.loads(数据) --将json数据转换成Python数据。 数据必须是字符串，字符串的内容必须是json格式的数据。result = json.loads(&apos;&quot;abc&quot;&apos;) --&gt; abc &lt;class &apos;str&apos;&gt; 1python --&gt; json (爬虫、数据可视化、数据分析) ---json.dumps() python json int或者float 》》 数字 str 》》 单引号变双引号 布尔 》》 Ture-&gt;ture False-&gt;false None 》》 None-&gt;null list 》》 数组 dict 》》 字典 tuple 》》 数组 123json.dumps(数据) --将python数据转换成json数据。 result = json.dumps(&apos;ABC&apos;) --&gt; &quot;ABC&quot; &lt;class &apos;str&apos;&gt; result是一个字符串","link":"/2019/10/26/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8Ajson%E6%96%87%E4%BB%B6/"},{"title":"装饰器、迭代器、生成器","text":"python的三大神器：装饰器、迭代器、生成器 1.函数就是变量123&quot;&quot;&quot;python中声明函数其实就是声明一个类型是function的变量，函数名就是变量名&quot;&quot;&quot; 12345678910111213a = 10def func1(): return &apos;hello&apos;def func2(): return [1, 2, 3]def func3(num): return num * num 1.给另一个变量赋值1234b = ac = func1print(b)print(c()) 2.重新赋值1234a = 100func1 = 200print(a)print(func1) 3.作为容器数据类型的元素12list1 = [1, 2, func2]print(list1[2]()[1]) 4.作为函数的参数12a = 10print(func3(a)) 5.函数作为函数的参数—-》实参高阶函数123456def func4(fn): fn()def func5(): print(&apos;hello world&apos;) 1234567func4(func5)&quot;&quot;&quot;系统实参高阶函数：列表.sort、sorted、max、min...中有个参数是key它的类型就是function。key的用法：它是一个函数，参数有且只有一个(代表序列中的元素)，还有一 个返回值(返回值就是比较标准)&quot;&quot;&quot; 12345678910111213141516stu = [ {&apos;name&apos;: &apos;wang&apos;, &apos;score&apos;: 97, &apos;age&apos;: 18, &apos;tel&apos;: &apos;12355&apos;}, {&apos;name&apos;: &apos;tang&apos;, &apos;score&apos;: 90, &apos;age&apos;: 16, &apos;tel&apos;: &apos;12358&apos;}, {&apos;name&apos;: &apos;zhao&apos;, &apos;score&apos;: 57, &apos;age&apos;: 18, &apos;tel&apos;: &apos;12354&apos;}, {&apos;name&apos;: &apos;xiao&apos;, &apos;score&apos;: 68, &apos;age&apos;: 14, &apos;tel&apos;: &apos;12350&apos;},]stu.sort(key=lambda item: item[&apos;tel&apos;][-1])print(stu)nums = [19, 89, 123, 75, 90]nums.sort(key=lambda item: item % 10 + item // 10 % 10 + item // 100)print(nums)max() ####6.变量作为返回值 变量作为变量返回值 1234567891011def operation(x:None): if x == &apos;+&apos;: def sum1(*arge): list1 = list(arge) x = 0 for y in list1: x += y return x return sum1 print(operation(&apos;+&apos;)(1,2,3)) 装饰器1.什么是装饰器123&quot;&quot;&quot;本质就是一个函数，是用来给函数添加功能用的&quot;&quot;&quot; 12345678910111213141516# 示例一：给函数添加功能(统计执行时间功能)import timedef sum1(): t1 = time.time() i = 0 while i &lt; 1000: print(&apos;aaaaaaaaaaaa&apos;) i += 1 t2 = time.time() print(&apos;{}&apos;.format(t2 - t1))sum1() 用装饰器给函数添加功能123456789101112131415# 示例二：给函数添加功能(统计执行时间功能)def num1(*args): list1 = list(args) sum1 = 1 for i in list1: sum1 *= i print(sum1)def statistics_time(fn, *args, **kwargs): ti = time.time() fn(*args, **kwargs) tii = time.time() print(&apos;{}&apos;.format(tii-ti))statistics_time(num1, 10, 10, 5, 2) 装饰器1234567891011121314151617&quot;&quot;&quot;a.语法def 函数名1(fn): def 函数2(*args, **kwargs): 实现添加功能的代码 fn(*args, **kwargs) return 函数2 b.说明函数名1 -装饰器名字(根据添加的功能命名)fn - 随便命名，类型是函数，指向的是需要添加功能的函数函数名2 - 实现添加功能的函数，随便命名，一般为test*args, **kwargs -固定写法fn(*args, **kwargs) -固定写法&quot;&quot;&quot; 装饰器 = 实参高阶函数 + 返回值高阶函数 + 糖语法 1234567891011121314def add_time(fn): def test(*args, **kwargs): ti = time.time() fn(*args, **kwargs) tii = time.time() print(&apos;执行时间&apos;, tii-ti) return test @add_time def print_(): print(&apos;hello&apos;) print_() 12345678910111213141516171819202122232425# 练习1def print_over(fn): def test(*args, **kwargs): fn(*args, **kwargs) print(&apos;调用完成&apos;) return test@print_overdef print_(m): return m ** 2print_(4)# 练习2def hex_re(fn): def test(*args, **kwargs): re = fn(*args, **kwargs) return hex(re) return test@hex_redef num(m): return m**2print(num(5)) 迭代器12345678910111213①什么是迭代器？(iter)迭代器是容器性数据类型(序列),迭代器中的元素只能通过将其他序列转换成迭代器或者创建生成器。迭代器中的元素：如果需要查看元素，需要将元素从迭代器取出，而且一旦取出就不能放回去。②创建迭代器iter(序列) -将序列转换成迭代器并返回③获取元素获取单个元素next(迭代器)------获取迭代器中的第一个元素遍历迭代器for x in 迭代器: 1234567iter1 =iter(&apos;hello&apos;) print(next(iter1)) --&gt;hprint(next(iter1)) --&gt;eprint(next(iter1)) --&gt;lprint(next(iter1)) --&gt;lprint(next(iter1)) --&gt;oprint(next(iter1)) --&gt;StopIteration,代表迭代器元素取完了 生成器1生成器的本质就是一个特殊的迭代器，容器有产生数据的能力。 12345①怎么创建生成器：调用一个带有yield关键字的函数，就可以得到一个生成器对象②生成器产生数据的原理:调用一个带有yield关键字的函数的时候，不会执行函数体，也不会获取返回值，而是创建一个生成器。生成器能产生多少个数据，以及每个数据的值，看执行完函数体会遇到几次yield生成器就可以产生几个数据，yield后面的值就是产生数据的值。每次获取生成器元素的时候，都会去执行相应的函数的函数体，执行到yield为止，取下一个元素就会从上次结束的位置往后执行。 1234567def func1(x): for i in range(x): yield istr1 = func1(10000)for item in str1: print(&apos;{:0&gt;10d}&apos;.format(item)) 12345678910# 练习：写一个学号生成器，范围和前缀穿件生成器的时候自己决定# 如 python19050001~python19050999def func1(str1,num): length = len(str(num)) for i in range(num): yield str1+str(i+1).zfill(length)str2 = func1(&apos;python1905&apos;,999)print(next(str2)) 生成式1生成式就是生成器的一种简写方式。 12345678910①形式一(表达式 for 变量 in 序列) --序列中有多少个元素，生成器就可以产生多少个数据。每次循环，表达式的值就是产生的数据的值(yield后的值)相当于以下函数def func(): for 变量 in 序列： yield 变量 gen1 = (x*2 for x in range(5))print(gen1)---&gt;0,2,4,6,8print(next(gen1)) 123456789101112②形式二(表达式 for 变量 in 序列 if 条件语句)相当于以下函数def func(): for 变量 in 序列： if 条件语句 yield 变量gen1 = (x*2 for x in range(5) if x%2)print(gen1)---&gt;2,6print(next(gen1)) 123456789101112③变形1.列表生成式[表达式 for 变量 in 序列] --相当于 list((表达式 for 变量 in 序列))[表达式 for 变量 in 序列 if 条件语句]2.集合生成式{表达式 for 变量 in 序列} --相当于set((表达式 for 变量 in 序列)){表达式 for 变量 in 序列 if 条件语句}3.生成式转字典dict(表达式 for 变量 in 序列) --表达式必须是有两个元素的序列。dict(表达式 for 变量 in 序列 if 条件语句) 12345一行代码交换字典的键值对dict2 = {&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3}new_ditc2 = dict((dict2[key], key) for key in dict2)print(new_ditc2)","link":"/2019/10/26/%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"正则表达式","text":"正则表达式很多地方都在用，它是字符匹配的很好的一个方法，这里讲的是python中正则的书写和使用方法 正则表达式什么是正则表达式1234&quot;&quot;&quot;正则表达式是用来描述字符串规律的一种语法，可以更加方便的解决字符串匹配、字符串查找、字符串切割等相关操作。&quot;&quot;&quot; 正则表达式的语法(通用)1.普通字符123&quot;&quot;&quot;如果正则表达式中出现普通字符，那么这个字符表示这个字符本身&quot;&quot;&quot; 2. .123&quot;&quot;&quot;一个正则表达式中的&apos;.&apos;,匹配一个任意字符&quot;&quot;&quot; 2.3.\\w \\W12\\w匹配字母、数字、下划线\\W匹配字母、数字、下划线 4.\\s \\S1234&quot;&quot;&quot;\\s空白字符：空格、回车(\\n)、制表符(\\t)\\S空白字符：空格、回车(\\n)、制表符(\\t)&quot;&quot;&quot; 5.\\d \\D12\\d匹配数字字符\\D匹配数字字符 6.[字符集]123456789101112&quot;&quot;&quot;a. [字符集] - 匹配字符集中任意一个字符 例如 [abc1] -&gt; 匹配一个字符a或者b或者c或者1 b. [字符1-字符2] - 匹配编码值在字符1到字符2编码值中的所有字符的任意一个 (注意字符1的编码值&lt;字符2编码值)字母字符：[a-zA-Z]小写字母[a-z]数字字符[0-9] -&gt; [0123456789][A2-8DCX] -&gt; [A2345678DCX]中文：[\\u4e00-\\u9fa5]组合：[\\d] -&gt; [0123456789]&quot;&quot;&quot; 1234567[^字符集] - 匹配字符集外任意一个字符&quot;&quot;&quot;非数字字符：[^0-9]非小写字母：[^a-z]非字母:[^a-zA-Z]非中文：[^\\u4e00-\\u9fa5]&quot;&quot;&quot; 7.\\b \\B123456\\b检测是否是单词边界\\B检测是否不是单词边界&quot;&quot;&quot;单词边界 - 凡是可以区分出两个不同单词的符号都是单词边界:空白字符、标点符号、字符串开头和结尾。&quot;&quot;&quot; 8. ^ $12^检测是否是字符串开头$检测是否是字符串结尾 控制匹配次数*1匹配0次或多次 +1匹配1次或多次 ?1匹配0次或1次 {}12341.{N} - 匹配N次2.{M,N} - 匹配M到N次(最多N次，最少M次) -MN之间不能打空格！！！！3.{M,} - 匹配至少M次4.{,N} - 匹配最多N次 贪婪和非贪婪12345&quot;&quot;&quot;匹配次数不确定的时候，匹配分为贪婪和不贪婪；默认都是贪婪的贪婪 - 在匹配成功的前提下，次数尽可能多的去匹配非贪婪 - 在匹配成功的前提下，次数尽可能少的去匹配(*?、 +?、 ??、 {M,N}?、{,N}?、{M,}?)&quot;&quot;&quot; 正则表达式的分支分支123&quot;&quot;&quot;正则1|正则2 -匹配一个字符串满足正则1或正则2&quot;&quot;&quot; 分组12345678a.做整体操作&quot;&quot;&quot;re_str = r&apos;(\\d{3}[a-zA-Z]{3})+&apos;print(re.fullmatch(re_str, &apos;123aad&apos;))re_str = r&apos;(\\d+=)+&apos;print(re.fullmatch(re_str, &apos;123=2=&apos;))&quot;&quot;&quot; 12345678910b.重复内容 - 在正则中，在数字前加&apos;\\&apos;来重复前面第几个分组匹配到的内容 一个()就是一个分组&quot;&quot;&quot;re_str = r&apos;(\\d{3})abc\\1&apos; # 重复前面第一个分组print(re.fullmatch(re_str, &apos;123abc123&apos;))print(&apos;=====================转义符号==========================&apos;)# 1) 转义符号 - 指的是为了让正则中哟特殊意义的符号的意义消失，而在这个符号前加入\\re_str = r&apos;\\..&apos; # 重复前面第一个分组print(re.fullmatch(re_str, &apos;.c&apos;)) 补充1除了^方法在[]中的最开头，-放在[]中的两个字符中间，其他单独存在有特殊意义的字符在[]中都是普通字符 123456re_str = r&apos;[.*+?].&apos;print(re.fullmatch(re_str, &apos;.c&apos;))print(re.fullmatch(re_str, &apos;?c&apos;))print(re.fullmatch(re_str, &apos;+c&apos;))re_str = r&apos;[\\-a]&apos;print(re.fullmatch(re_str, &apos;-&apos;)) re模块的使用匹配模块fullmatch和match123456&quot;&quot;&quot;fullmatch(正则表达式,字符串) - 完全匹配，让整个字符串和正则表达式进行匹配 如果匹配成功返回匹配对象，否则返回Nonematch(正则表达式,字符串) - 让字符串开头和正则表达式进行匹配,如果匹配成功返 回匹配对象，否则返回None&quot;&quot;&quot; 查找模块search123&quot;&quot;&quot;search(正则表达式,字符串) - 获取字符串中第一个满足正则表达式的子串。如果有就返回匹配对象，没有就None&quot;&quot;&quot; findall12345print(re.findall(r&apos;\\d{3}&apos;, &apos;asd1234ad456789&apos;))# 如果放在findall中的正则表达式中有一个分组；返回列表中的元素只取匹配结果中分组对应的部分print(re.findall(r&apos;(\\d{3})[a-z]{2}&apos;, &apos;asd1234ad456789asd&apos;))# 如果放在findall中的正则表达式中有多个分组；返回列表中的元素是元组，元组的元素是分组对应的部分print(re.findall(r&apos;(\\d{3})([a-z]{2})&apos;, &apos;asd1234ad456789asd&apos;)) finditer123&quot;&quot;&quot;finditer(正则表达式,字符串) - 获取字符串中所有满足条件的子串，返回值是迭代器，元素是匹配对象&quot;&quot;&quot; split1234&quot;&quot;&quot;re.split(正则表达式,字符串) - 将字符串中所有满足条件的子串作为切割点，对字符串进行切割,返回是列表 ，元素是剩下的字符&quot;&quot;&quot; 12print(re.split(r&apos;[.,\\s]&apos;, &apos;asds,sda.sada,ad 15 4,33&apos;))print(re.split(r&apos;\\d+&apos;, &apos;sdsd21asdas5da1as5dw51adaw1d23dawd&apos;)) sub123&quot;&quot;&quot;sub(正则表达式,字符串1,字符串2) - 将字符串2中满足正则的子串替换成字符串1&quot;&quot;&quot; 1234str1 = &apos;asdasda1151dasdsadad&apos;print(re.sub(&apos;\\d&apos;, &apos;+&apos;, str1))str2 = &apos;SDFGdfGEVtessdokoooOdfew&apos;print(re.sub(&apos;o&apos;, &apos;+&apos;, str2, flags=re.IGNORECASE))","link":"/2019/10/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"面向对象基础","text":"类就是具有相同属性和方法的对象的集合 1.编程思想123①面向过程编程 - 以逻辑和算法为工具②面向函数式编程 - 以函数为工具③面向对象编程 - 以类和对象为工具 2.类和对象12345类：是拥有相同功能和相同属性的对象的集合。 - 类是抽象的对象：是类的实例 - 对象是具体的如果人是类 - 小王就是对象如果杯子是类 - 桌子上我的水杯就是对象 3.类和对象声明1.类的声明类就是拥有相同功能(函数)和相同属性(保存数据的变量，也叫属性)的集合 1)语法123class 类名: 类的说明文档 类的内容 2)说明1234567891011&quot;&quot;&quot;class - 关键字，固定写法类名 - 程序员自己命名，不能是标识符、关键字，规范：见名知意，驼峰式命名并且首字母大写，如StudentScoreList、StudentName,不能使用系统提供的函数名、模块名或类名。类的说明文档 - 对类进行描述，主要说明类中提供的功能有哪些类的内容 - 类中的函数(方法)和属性。 方法：对象方法、类方法、静态方法。属性：类的字段和对象属性。&quot;&quot;&quot; 123456789101112class Human: &quot;&quot;&quot; 人类:有学习、吃饭、睡觉的功能 &quot;&quot;&quot; def study(self): print(&apos;study&apos;) def eat(self, food): print(&apos;eat - {}&apos;.format(food)) def sleep(self): print(&apos;sleep&apos;) 2.创建对象1)语法1类() - 创建指定类对应的对象 2)说明1类 - 已经声明过的类 1p1 = Person() # 创建Person类的对象 3.构造方法1234567&quot;&quot;&quot;构造方法就是用来创建对象函数；构造方法的名字与类名相同python中的构造方法：a.在Python中声明类的时候，系统会自动创建一个函数名和类名相同的构造方法。b.当通过构造方法创建对象的时候，会自动调用__init__方法来对对象进行初始化操作&quot;&quot;&quot; 4.init方法123&quot;&quot;&quot;是类中一个特殊的对象方法：这个方法不需要主动调用，用来给对象初始化&quot;&quot;&quot; 12345&quot;&quot;&quot;a.通过构造方法创建对象的时候，类中__init__方法会被自动调用b.类中的__init__方法可以写，也可以不写，如果写函数名和参数self不能动，但是可以随意添加其他参数c.如果__init__方法中除了self以外的参数，那么创建对象的时候需要给构造方法中给这些参数传参。&quot;&quot;&quot; 5.属性什么是属性123&quot;&quot;&quot;属性就是声明在类中的变量；python中类的属性分为类的字段和对象属性两种&quot;&quot;&quot; 类的字段123456&quot;&quot;&quot;直接声明在类中，但是在函数外面的变量就是字段a.怎么声明：直接声明在类中b.怎么使用：通过类使用，以&apos;类.字段&apos;的方式使用c.什么时候用：保存的属性值不会因为对象的不同而不一样时使用&quot;&quot;&quot; 对象属性12345&quot;&quot;&quot;a.怎么声明：声明在__init__方法中，以&apos;self.属性 = 值&apos;的形式声明b.怎么使用：通过对象使用，以&apos;对象.属性&apos;的方式使用c.什么时候用：保存的属性值会因为对象的不同而不一样时就是用对象属性&quot;&quot;&quot; 6.对象属性的增删改查查123456&quot;&quot;&quot;1.对象.属性 - 获取指定对象指定属性，当属性不存在的时候会报错。2.getattr(对象，属性名，默认值) - 获取指定对象指定属性的值，属性名必须是字符串，没有该属性会返回指定的默认值&quot;&quot;&quot; 增、改123456&quot;&quot;&quot;1.对象.属性 = 值 - 当属性存在的时候，修改指定属性的值，当属性不存在的时候，给对象添加属性。2.setattr(对象，属性名，值) - 修改指定对象指定属性的值，属性名必须是字符串，没有该属性会添加指定属性赋指定值&quot;&quot;&quot; 删123456&quot;&quot;&quot;1.del 对象.属性 - 删除对象中指定的属性2.delattr(对象，属性名) - 删除对象中指定的属性，属性名必须是字符串&quot;&quot;&quot; 7.内置类属性123&quot;&quot;&quot;创建类的时候，系统自动添加的属性就是内置类属性。&quot;&quot;&quot; 1234# 1)__name__&quot;&quot;&quot;类.__name__ -&gt; 获取当前类的类名，返回值是类名字符串&quot;&quot;&quot; 1234# 2)__doc__&quot;&quot;&quot;类.__doc__ -&gt; 获取类的说明文档，返回值是字符串&quot;&quot;&quot; 1234# 3)__class__&quot;&quot;&quot;对象.__class__ -&gt; 获取指定对象对应的类，返回值是字符串，作用跟type(对象)一样&quot;&quot;&quot; 12345# 4)__dict__&quot;&quot;&quot;类.__dict__ -&gt; 获取指定类中所有的字段和对应的值，以字典的形式返回。对象.__dict__ -&gt; 获取对象所有的属性和对应的值，以字典的形式返回。&quot;&quot;&quot; 12345# 5)__module__&quot;&quot;&quot;类.__module__ -&gt; 获取指定类所在模块的模块名object - 是基类&quot;&quot;&quot; 1234# 6)__bases__&quot;&quot;&quot;类.__bases__ -&gt; 获取指定类的父类，返回值是一个元组&quot;&quot;&quot; 8.slots魔法1234567891011121314151617181920212223242526&quot;&quot;&quot; __author__ = Tang &quot;&quot;&quot;# 注意 slots和__dict__只能二选一！！！&quot;&quot;&quot;如果类中设置了slots的值，这个类的对象就不能使用内置类属性__dict__&quot;&quot;&quot;class Person: # __slots__ = (&apos;name&apos;, &apos;age&apos;, &apos;gender&apos;) def __init__(self, name, age=18): self.name = name self.age = age def __repr__(self): return &apos;&lt;%s&gt;&apos; % (str(self.__dict__)[1:-1])def main(): p1 = Person(&apos;xiao&apos;) print(p1.name) p1.gender = &apos;woman&apos; print(p1)if __name__ == &apos;__main__&apos;: main() 9.类中的三种方法12# 类中的方法有三种：对象方法、类方法、静态方法&quot;&quot;&quot; 123451.对象方法a.怎么声明：直接声明在类中b.怎么调用：用对象调用c.特点：自带一个参数self，self在调用时不需要传参，系统会自动将当前对象传给它d.什么时候用：(实现函数功能需要对象) 实现函数的功能需要用到对象属性 123452.类方法a.怎么声明：在装饰器@classmethod后声明的函数(声明前加@classmethod)b.怎么调用：用类来调用c.特点：有默认参数cls。cls在调用的时候不用传参，系统会把当前类传给它 --- (类能做的cls都能做)d.什么时候用：(实现函数功能不需要对象的前提下，需要类) 实现函数的功能不需要用到对象属性，需要用到类 1234563.静态方法a.怎么声明：在装饰器@staticmethod后声明的函数(声明前加@classmethod)b.怎么调用：用类来调用c.特点：没有默认参数d.什么时候用：(实现函数功能不需要对象的前提下，不需要类)&quot;&quot;&quot;","link":"/2019/10/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[{"name":"HTML基础","slug":"HTML基础","link":"/categories/HTML%E5%9F%BA%E7%A1%80/"},{"name":"python语言基础","slug":"python语言基础","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"python语言基础-socket编程","slug":"python语言基础-socket编程","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-socket%E7%BC%96%E7%A8%8B/"},{"name":"python语言基础-数据类型","slug":"python语言基础-数据类型","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"python语言基础-内存管理","slug":"python语言基础-内存管理","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"python语言基础-函数部分","slug":"python语言基础-函数部分","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86/"},{"name":"python语言基础-多线程","slug":"python语言基础-多线程","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"python语言基础-面向对象","slug":"python语言基础-面向对象","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Linux基础","slug":"Linux基础","link":"/categories/Linux%E5%9F%BA%E7%A1%80/"},{"name":"python语言基础-异常捕获","slug":"python语言基础-异常捕获","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"},{"name":"python语言基础-文件操作部分","slug":"python语言基础-文件操作部分","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E9%83%A8%E5%88%86/"},{"name":"python语言基础-正则表达式","slug":"python语言基础-正则表达式","link":"/categories/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}